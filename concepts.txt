Linear Regression is a supervised machine learning algorithm where the predicted output is continuous and has a constant slope. Itâ€™s used to predict values within a continuous range, (e.g. sales, price) rather than trying to classify them into categories (e.g. cat, dog). There are two main types:

Simple regression

Simple linear regression uses traditional slope-intercept form, where ğ‘šm and ğ‘b are the variables our algorithm will try to â€œlearnâ€ to produce the most accurate predictions. ğ‘¥x represents our input data and ğ‘¦y represents our prediction.

ğ‘¦=ğ‘šğ‘¥+ğ‘
y=mx+b
Multivariable regression

A more complex, multi-variable linear equation might look like this, where ğ‘¤w represents the coefficients, or weights, our model will try to learn.

ğ‘“(ğ‘¥,ğ‘¦,ğ‘§)=ğ‘¤1ğ‘¥+ğ‘¤2ğ‘¦+ğ‘¤3ğ‘§
f(x,y,z)=w1x+w2y+w3z
The variables ğ‘¥,ğ‘¦,ğ‘§x,y,z represent the attributes, or distinct pieces of information, we have about each observation. For sales predictions, these attributes might include a companyâ€™s advertising spend on radio, TV, and newspapers.

ğ‘†ğ‘ğ‘™ğ‘’ğ‘ =ğ‘¤1ğ‘…ğ‘ğ‘‘ğ‘–ğ‘œ+ğ‘¤2ğ‘‡ğ‘‰+ğ‘¤3ğ‘ğ‘’ğ‘¤ğ‘ 
Sales=w1Radio+w2TV+w3News
Simple regression
Letâ€™s say we are given a dataset with the following columns (features): how much a company spends on Radio advertising each year and its annual Sales in terms of units sold. We are trying to develop an equation that will let us to predict units sold based on how much a company spends on radio advertising. The rows (observations) represent companies.

Company	Radio ($)	Sales
Amazon	37.8	22.1
Google	39.3	10.4
Facebook	45.9	18.3
Apple	41.3	18.5
Making predictions
Our prediction function outputs an estimate of sales given a companyâ€™s radio advertising spend and our current values for Weight and Bias.

ğ‘†ğ‘ğ‘™ğ‘’ğ‘ =ğ‘Šğ‘’ğ‘–ğ‘”â„ğ‘¡â‹…ğ‘…ğ‘ğ‘‘ğ‘–ğ‘œ+ğµğ‘–ğ‘ğ‘ 
Sales=Weightâ‹…Radio+Bias
Weight
the coefficient for the Radio independent variable. In machine learning we call coefficients weights.
Radio
the independent variable. In machine learning we call these variables features.
Bias
the intercept where our line intercepts the y-axis. In machine learning we can call intercepts bias. Bias offsets all predictions that we make.
Our algorithm will try to learn the correct values for Weight and Bias. By the end of our training, our equation will approximate the line of best fit.

_images/linear_regression_line_intro.png
Code

def predict_sales(radio, weight, bias):
    return weight*radio + bias
Cost function
The prediction function is nice, but for our purposes we donâ€™t really need it. What we need is a cost function so we can start optimizing our weights.

Letâ€™s use MSE (L2) as our cost function. MSE measures the average squared difference between an observationâ€™s actual and predicted values. The output is a single number representing the cost, or score, associated with our current set of weights. Our goal is to minimize MSE to improve the accuracy of our model.

Math

Given our simple linear equation ğ‘¦=ğ‘šğ‘¥+ğ‘y=mx+b, we can calculate MSE as:

ğ‘€ğ‘†ğ¸=1ğ‘âˆ‘ğ‘–=1ğ‘›(ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘))2
MSE=1Nâˆ‘i=1n(yiâˆ’(mxi+b))2
Note

ğ‘N is the total number of observations (data points)
1ğ‘âˆ‘ğ‘›ğ‘–=11Nâˆ‘i=1n is the mean
ğ‘¦ğ‘–yi is the actual value of an observation and ğ‘šğ‘¥ğ‘–+ğ‘mxi+b is our prediction
Code

def cost_function(radio, sales, weight, bias):
    companies = len(radio)
    total_error = 0.0
    for i in range(companies):
        total_error += (sales[i] - (weight*radio[i] + bias))**2
    return total_error / companies
Gradient descent
To minimize MSE we use Gradient Descent to calculate the gradient of our cost function. Gradient descent consists of looking at the error that our weight currently gives us, using the derivative of the cost function to find the gradient (The slope of the cost function using our current weight), and then changing our weight to move in the direction opposite of the gradient. We need to move in the opposite direction of the gradient since the gradient points up the slope instead of down it, so we move in the opposite direction to try to decrease our error.

Math

There are two parameters (coefficients) in our cost function we can control: weight ğ‘šm and bias ğ‘b. Since we need to consider the impact each one has on the final prediction, we use partial derivatives. To find the partial derivatives, we use the Chain rule. We need the chain rule because (ğ‘¦âˆ’(ğ‘šğ‘¥+ğ‘))2(yâˆ’(mx+b))2 is really 2 nested functions: the inner function ğ‘¦âˆ’(ğ‘šğ‘¥+ğ‘)yâˆ’(mx+b) and the outer function ğ‘¥2x2.

Returning to our cost function:

ğ‘“(ğ‘š,ğ‘)=1ğ‘âˆ‘ğ‘–=1ğ‘›(ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘))2
f(m,b)=1Nâˆ‘i=1n(yiâˆ’(mxi+b))2
Using the following:

(ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘))2=ğ´(ğµ(ğ‘š,ğ‘))
(yiâˆ’(mxi+b))2=A(B(m,b))
We can split the derivative into

ğ´(ğ‘¥)=ğ‘¥2ğ‘‘ğ‘“ğ‘‘ğ‘¥=ğ´â€²(ğ‘¥)=2ğ‘¥
A(x)=x2dfdx=Aâ€²(x)=2x
and

ğµ(ğ‘š,ğ‘)=ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘)=ğ‘¦ğ‘–âˆ’ğ‘šğ‘¥ğ‘–âˆ’ğ‘ğ‘‘ğ‘¥ğ‘‘ğ‘š=ğµâ€²(ğ‘š)=0âˆ’ğ‘¥ğ‘–âˆ’0=âˆ’ğ‘¥ğ‘–ğ‘‘ğ‘¥ğ‘‘ğ‘=ğµâ€²(ğ‘)=0âˆ’0âˆ’1=âˆ’1
B(m,b)=yiâˆ’(mxi+b)=yiâˆ’mxiâˆ’bdxdm=Bâ€²(m)=0âˆ’xiâˆ’0=âˆ’xidxdb=Bâ€²(b)=0âˆ’0âˆ’1=âˆ’1
And then using the Chain rule which states:

ğ‘‘ğ‘“ğ‘‘ğ‘š=ğ‘‘ğ‘“ğ‘‘ğ‘¥ğ‘‘ğ‘¥ğ‘‘ğ‘šğ‘‘ğ‘“ğ‘‘ğ‘=ğ‘‘ğ‘“ğ‘‘ğ‘¥ğ‘‘ğ‘¥ğ‘‘ğ‘
dfdm=dfdxdxdmdfdb=dfdxdxdb
We then plug in each of the parts to get the following derivatives

ğ‘‘ğ‘“ğ‘‘ğ‘š=ğ´â€²(ğµ(ğ‘š,ğ‘“))ğµâ€²(ğ‘š)=2(ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘))â‹…âˆ’ğ‘¥ğ‘–ğ‘‘ğ‘“ğ‘‘ğ‘=ğ´â€²(ğµ(ğ‘š,ğ‘“))ğµâ€²(ğ‘)=2(ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘))â‹…âˆ’1
dfdm=Aâ€²(B(m,f))Bâ€²(m)=2(yiâˆ’(mxi+b))â‹…âˆ’xidfdb=Aâ€²(B(m,f))Bâ€²(b)=2(yiâˆ’(mxi+b))â‹…âˆ’1
We can calculate the gradient of this cost function as:

ğ‘“â€²(ğ‘š,ğ‘)=[ğ‘‘ğ‘“ğ‘‘ğ‘šğ‘‘ğ‘“ğ‘‘ğ‘]=[1ğ‘âˆ‘âˆ’ğ‘¥ğ‘–â‹…2(ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘))1ğ‘âˆ‘âˆ’1â‹…2(ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘))]=[1ğ‘âˆ‘âˆ’2ğ‘¥ğ‘–(ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘))1ğ‘âˆ‘âˆ’2(ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘))]
fâ€²(m,b)=[dfdmdfdb]=[1Nâˆ‘âˆ’xiâ‹…2(yiâˆ’(mxi+b))1Nâˆ‘âˆ’1â‹…2(yiâˆ’(mxi+b))]=[1Nâˆ‘âˆ’2xi(yiâˆ’(mxi+b))1Nâˆ‘âˆ’2(yiâˆ’(mxi+b))]
Code

To solve for the gradient, we iterate through our data points using our new weight and bias values and take the average of the partial derivatives. The resulting gradient tells us the slope of our cost function at our current position (i.e. weight and bias) and the direction we should update to reduce our cost function (we move in the direction opposite the gradient). The size of our update is controlled by the learning rate.

def update_weights(radio, sales, weight, bias, learning_rate):
    weight_deriv = 0
    bias_deriv = 0
    companies = len(radio)

    for i in range(companies):
        # Calculate partial derivatives
        # -2x(y - (mx + b))
        weight_deriv += -2*radio[i] * (sales[i] - (weight*radio[i] + bias))

        # -2(y - (mx + b))
        bias_deriv += -2*(sales[i] - (weight*radio[i] + bias))

    # We subtract because the derivatives point in direction of steepest ascent
    weight -= (weight_deriv / companies) * learning_rate
    bias -= (bias_deriv / companies) * learning_rate

    return weight, bias
Training
Training a model is the process of iteratively improving your prediction equation by looping through the dataset multiple times, each time updating the weight and bias values in the direction indicated by the slope of the cost function (gradient). Training is complete when we reach an acceptable error threshold, or when subsequent training iterations fail to reduce our cost.

Before training we need to initialize our weights (set default values), set our hyperparameters (learning rate and number of iterations), and prepare to log our progress over each iteration.

Code

def train(radio, sales, weight, bias, learning_rate, iters):
    cost_history = []

    for i in range(iters):
        weight,bias = update_weights(radio, sales, weight, bias, learning_rate)

        #Calculate cost for auditing purposes
        cost = cost_function(radio, sales, weight, bias)
        cost_history.append(cost)

        # Log Progress
        if i % 10 == 0:
            print "iter={:d}    weight={:.2f}    bias={:.4f}    cost={:.2}".format(i, weight, bias, cost)

    return weight, bias, cost_history
Model evaluation
If our model is working, we should see our cost decrease after every iteration.

Logging

iter=1     weight=.03    bias=.0014    cost=197.25
iter=10    weight=.28    bias=.0116    cost=74.65
iter=20    weight=.39    bias=.0177    cost=49.48
iter=30    weight=.44    bias=.0219    cost=44.31
iter=30    weight=.46    bias=.0249    cost=43.28
Visualizing

_images/linear_regression_line_1.png_images/linear_regression_line_2.png_images/linear_regression_line_3.png_images/linear_regression_line_4.png
Cost history

_images/linear_regression_training_cost.png
Summary
By learning the best values for weight (.46) and bias (.25), we now have an equation that predicts future sales based on radio advertising investment.

ğ‘†ğ‘ğ‘™ğ‘’ğ‘ =.46ğ‘…ğ‘ğ‘‘ğ‘–ğ‘œ+.025
Sales=.46Radio+.025
How would our model perform in the real world? Iâ€™ll let you think about it :)

Multivariable regression
Letâ€™s say we are given data on TV, radio, and newspaper advertising spend for a list of companies, and our goal is to predict sales in terms of units sold.

Company	TV	Radio	News	Units
Amazon	230.1	37.8	69.1	22.1
Google	44.5	39.3	23.1	10.4
Facebook	17.2	45.9	34.7	18.3
Apple	151.5	41.3	13.2	18.5
Growing complexity
As the number of features grows, the complexity of our model increases and it becomes increasingly difficult to visualize, or even comprehend, our data.

_images/linear_regression_3d_plane_mlr.png
One solution is to break the data apart and compare 1-2 features at a time. In this example we explore how Radio and TV investment impacts Sales.

Normalization
As the number of features grows, calculating gradient takes longer to compute. We can speed this up by â€œnormalizingâ€ our input data to ensure all values are within the same range. This is especially important for datasets with high standard deviations or differences in the ranges of the attributes. Our goal now will be to normalize our features so they are all in the range -1 to 1.

Code

For each feature column {
    #1 Subtract the mean of the column (mean normalization)
    #2 Divide by the range of the column (feature scaling)
}
Our input is a 200 x 3 matrix containing TV, Radio, and Newspaper data. Our output is a normalized matrix of the same shape with all values between -1 and 1.

def normalize(features):
    **
    features     -   (200, 3)
    features.T   -   (3, 200)

    We transpose the input matrix, swapping
    cols and rows to make vector math easier
    **

    for feature in features.T:
        fmean = np.mean(feature)
        frange = np.amax(feature) - np.amin(feature)

        #Vector Subtraction
        feature -= fmean

        #Vector Division
        feature /= frange

    return features
Note

Matrix math. Before we continue, itâ€™s important to understand basic Linear Algebra concepts as well as numpy functions like numpy.dot().

Making predictions
Our predict function outputs an estimate of sales given our current weights (coefficients) and a companyâ€™s TV, radio, and newspaper spend. Our model will try to identify weight values that most reduce our cost function.

ğ‘†ğ‘ğ‘™ğ‘’ğ‘ =ğ‘Š1ğ‘‡ğ‘‰+ğ‘Š2ğ‘…ğ‘ğ‘‘ğ‘–ğ‘œ+ğ‘Š3ğ‘ğ‘’ğ‘¤ğ‘ ğ‘ğ‘ğ‘ğ‘’ğ‘Ÿ
Sales=W1TV+W2Radio+W3Newspaper
def predict(features, weights):
  **
  features - (200, 3)
  weights - (3, 1)
  predictions - (200,1)
  **
  predictions = np.dot(features, weights)
  return predictions
Initialize weights
W1 = 0.0
W2 = 0.0
W3 = 0.0
weights = np.array([
    [W1],
    [W2],
    [W3]
])
Cost function
Now we need a cost function to audit how our model is performing. The math is the same, except we swap the ğ‘šğ‘¥+ğ‘mx+b expression for ğ‘Š1ğ‘¥1+ğ‘Š2ğ‘¥2+ğ‘Š3ğ‘¥3W1x1+W2x2+W3x3. We also divide the expression by 2 to make derivative calculations simpler.

ğ‘€ğ‘†ğ¸=12ğ‘âˆ‘ğ‘–=1ğ‘›(ğ‘¦ğ‘–âˆ’(ğ‘Š1ğ‘¥1+ğ‘Š2ğ‘¥2+ğ‘Š3ğ‘¥3))2
MSE=12Nâˆ‘i=1n(yiâˆ’(W1x1+W2x2+W3x3))2
def cost_function(features, targets, weights):
    **
    features:(200,3)
    targets: (200,1)
    weights:(3,1)
    returns average squared error among predictions
    **
    N = len(targets)

    predictions = predict(features, weights)

    # Matrix math lets use do this without looping
    sq_error = (predictions - targets)**2

    # Return average squared error among predictions
    return 1.0/(2*N) * sq_error.sum()
Gradient descent
Again using the Chain rule we can compute the gradientâ€“a vector of partial derivatives describing the slope of the cost function for each weight.

ğ‘“â€²(ğ‘Š1)=âˆ’ğ‘¥1(ğ‘¦âˆ’(ğ‘Š1ğ‘¥1+ğ‘Š2ğ‘¥2+ğ‘Š3ğ‘¥3))ğ‘“â€²(ğ‘Š2)=âˆ’ğ‘¥2(ğ‘¦âˆ’(ğ‘Š1ğ‘¥1+ğ‘Š2ğ‘¥2+ğ‘Š3ğ‘¥3))ğ‘“â€²(ğ‘Š3)=âˆ’ğ‘¥3(ğ‘¦âˆ’(ğ‘Š1ğ‘¥1+ğ‘Š2ğ‘¥2+ğ‘Š3ğ‘¥3))
fâ€²(W1)=âˆ’x1(yâˆ’(W1x1+W2x2+W3x3))fâ€²(W2)=âˆ’x2(yâˆ’(W1x1+W2x2+W3x3))fâ€²(W3)=âˆ’x3(yâˆ’(W1x1+W2x2+W3x3))
def update_weights(features, targets, weights, lr):
    '''
    Features:(200, 3)
    Targets: (200, 1)
    Weights:(3, 1)
    '''
    predictions = predict(features, weights)

    #Extract our features
    x1 = features[:,0]
    x2 = features[:,1]
    x3 = features[:,2]

    # Use matrix cross product (*) to simultaneously
    # calculate the derivative for each weight
    d_w1 = -x1*(targets - predictions)
    d_w2 = -x2*(targets - predictions)
    d_w3 = -x3*(targets - predictions)

    # Multiply the mean derivative by the learning rate
    # and subtract from our weights (remember gradient points in direction of steepest ASCENT)
    weights[0][0] -= (lr * np.mean(d_w1))
    weights[1][0] -= (lr * np.mean(d_w2))
    weights[2][0] -= (lr * np.mean(d_w3))

    return weights
And thatâ€™s it! Multivariate linear regression.

Simplifying with matrices
The gradient descent code above has a lot of duplication. Can we improve it somehow? One way to refactor would be to loop through our features and weightsâ€“allowing our function to handle any number of features. However there is another even better technique: vectorized gradient descent.

Math

We use the same formula as above, but instead of operating on a single feature at a time, we use matrix multiplication to operative on all features and weights simultaneously. We replace the ğ‘¥ğ‘–xi terms with a single feature matrix ğ‘‹X.

ğ‘”ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘’ğ‘›ğ‘¡=âˆ’ğ‘‹(ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡ğ‘ âˆ’ğ‘ğ‘Ÿğ‘’ğ‘‘ğ‘–ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ )
gradient=âˆ’X(targetsâˆ’predictions)
Code

X = [
    [x1, x2, x3]
    [x1, x2, x3]
    .
    .
    .
    [x1, x2, x3]
]

targets = [
    [1],
    [2],
    [3]
]

def update_weights_vectorized(X, targets, weights, lr):
    **
    gradient = X.T * (predictions - targets) / N
    X: (200, 3)
    Targets: (200, 1)
    Weights: (3, 1)
    **
    companies = len(X)

    #1 - Get Predictions
    predictions = predict(X, weights)

    #2 - Calculate error/loss
    error = targets - predictions

    #3 Transpose features from (200, 3) to (3, 200)
    # So we can multiply w the (200,1)  error matrix.
    # Returns a (3,1) matrix holding 3 partial derivatives --
    # one for each feature -- representing the aggregate
    # slope of the cost function across all observations
    gradient = np.dot(-X.T,  error)

    #4 Take the average error derivative for each feature
    gradient /= companies

    #5 - Multiply the gradient by our learning rate
    gradient *= lr

    #6 - Subtract from our weights to minimize cost
    weights -= gradient

    return weights
Bias term
Our train function is the same as for simple linear regression, however weâ€™re going to make one final tweak before running: add a bias term to our feature matrix.

In our example, itâ€™s very unlikely that sales would be zero if companies stopped advertising. Possible reasons for this might include past advertising, existing customer relationships, retail locations, and salespeople. A bias term will help us capture this base case.

Code

Below we add a constant 1 to our features matrix. By setting this value to 1, it turns our bias term into a constant.

bias = np.ones(shape=(len(features),1))
features = np.append(bias, features, axis=1)
Model evaluation
After training our model through 1000 iterations with a learning rate of .0005, we finally arrive at a set of weights we can use to make predictions:

ğ‘†ğ‘ğ‘™ğ‘’ğ‘ =4.7ğ‘‡ğ‘‰+3.5ğ‘…ğ‘ğ‘‘ğ‘–ğ‘œ+.81ğ‘ğ‘’ğ‘¤ğ‘ ğ‘ğ‘ğ‘ğ‘’ğ‘Ÿ+13.9
Sales=4.7TV+3.5Radio+.81Newspaper+13.9
Our MSE cost dropped from 110.86 to 6.25.

Gradient Descent
Gradient descent is an optimization algorithm used to minimize some function by iteratively moving in the direction of steepest descent as defined by the negative of the gradient. In machine learning, we use gradient descent to update the parameters of our model. Parameters refer to coefficients in Linear Regression and weights in neural networks.

Introduction
Consider the 3-dimensional graph below in the context of a cost function. Our goal is to move from the mountain in the top right corner (high cost) to the dark blue sea in the bottom left (low cost). The arrows represent the direction of steepest descent (negative gradient) from any given pointâ€“the direction that decreases the cost function as quickly as possible. Source

_images/gradient_descent.png
Starting at the top of the mountain, we take our first step downhill in the direction specified by the negative gradient. Next we recalculate the negative gradient (passing in the coordinates of our new point) and take another step in the direction it specifies. We continue this process iteratively until we get to the bottom of our graph, or to a point where we can no longer move downhillâ€“a local minimum. image source.

_images/gradient_descent_demystified.png
Learning rate
The size of these steps is called the learning rate. With a high learning rate we can cover more ground each step, but we risk overshooting the lowest point since the slope of the hill is constantly changing. With a very low learning rate, we can confidently move in the direction of the negative gradient since we are recalculating it so frequently. A low learning rate is more precise, but calculating the gradient is time-consuming, so it will take us a very long time to get to the bottom.

Cost function
A Loss Functions tells us â€œhow goodâ€ our model is at making predictions for a given set of parameters. The cost function has its own curve and its own gradients. The slope of this curve tells us how to update our parameters to make the model more accurate.

Step-by-step
Now letâ€™s run gradient descent using our new cost function. There are two parameters in our cost function we can control: ğ‘šm (weight) and ğ‘b (bias). Since we need to consider the impact each one has on the final prediction, we need to use partial derivatives. We calculate the partial derivatives of the cost function with respect to each parameter and store the results in a gradient.

Math

Given the cost function:

ğ‘“(ğ‘š,ğ‘)=1ğ‘âˆ‘ğ‘–=1ğ‘›(ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘))2
f(m,b)=1Nâˆ‘i=1n(yiâˆ’(mxi+b))2
The gradient can be calculated as:

ğ‘“â€²(ğ‘š,ğ‘)=[ğ‘‘ğ‘“ğ‘‘ğ‘šğ‘‘ğ‘“ğ‘‘ğ‘]=[1ğ‘âˆ‘âˆ’2ğ‘¥ğ‘–(ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘))1ğ‘âˆ‘âˆ’2(ğ‘¦ğ‘–âˆ’(ğ‘šğ‘¥ğ‘–+ğ‘))]
fâ€²(m,b)=[dfdmdfdb]=[1Nâˆ‘âˆ’2xi(yiâˆ’(mxi+b))1Nâˆ‘âˆ’2(yiâˆ’(mxi+b))]
To solve for the gradient, we iterate through our data points using our new ğ‘šm and ğ‘b values and compute the partial derivatives. This new gradient tells us the slope of our cost function at our current position (current parameter values) and the direction we should move to update our parameters. The size of our update is controlled by the learning rate.

Code

def update_weights(m, b, X, Y, learning_rate):
    m_deriv = 0
    b_deriv = 0
    N = len(X)
    for i in range(N):
        # Calculate partial derivatives
        # -2x(y - (mx + b))
        m_deriv += -2*X[i] * (Y[i] - (m*X[i] + b))

        # -2(y - (mx + b))
        b_deriv += -2*(Y[i] - (m*X[i] + b))

    # We subtract because the derivatives point in direction of steepest ascent
    m -= (m_deriv / float(N)) * learning_rate
    b -= (b_deriv / float(N)) * learning_rate

    return m, b
    
 Logistic regression is a classification algorithm used to assign observations to a discrete set of classes. Unlike linear regression which outputs continuous number values, logistic regression transforms its output using the logistic sigmoid function to return a probability value which can then be mapped to two or more discrete classes.

Comparison to linear regression
Given data on time spent studying and exam scores. Linear Regression and logistic regression can predict different things:

Linear Regression could help us predict the studentâ€™s test score on a scale of 0 - 100. Linear regression predictions are continuous (numbers in a range).
Logistic Regression could help use predict whether the student passed or failed. Logistic regression predictions are discrete (only specific values or categories are allowed). We can also view probability scores underlying the modelâ€™s classifications.
Types of logistic regression
Binary (Pass/Fail)
Multi (Cats, Dogs, Sheep)
Ordinal (Low, Medium, High)
Binary logistic regression
Say weâ€™re given data on student exam results and our goal is to predict whether a student will pass or fail based on number of hours slept and hours spent studying. We have two features (hours slept, hours studied) and two classes: passed (1) and failed (0).

Studied	Slept	Passed
4.85	9.63	1
8.62	3.23	0
5.43	8.23	1
9.21	6.34	0
Graphically we could represent our data with a scatter plot.

_images/logistic_regression_exam_scores_scatter.png
Sigmoid activation
In order to map predicted values to probabilities, we use the sigmoid function. The function maps any real value into another value between 0 and 1. In machine learning, we use sigmoid to map predictions to probabilities.

Math

ğ‘†(ğ‘§)=11+ğ‘’âˆ’ğ‘§
S(z)=11+eâˆ’z
Note

ğ‘ (ğ‘§)s(z) = output between 0 and 1 (probability estimate)
ğ‘§z = input to the function (your algorithmâ€™s prediction e.g. mx + b)
ğ‘’e = base of natural log
Graph

_images/sigmoid.png
Code

def sigmoid(z):
  return 1.0 / (1 + np.exp(-z))
Decision boundary
Our current prediction function returns a probability score between 0 and 1. In order to map this to a discrete class (true/false, cat/dog), we select a threshold value or tipping point above which we will classify values into class 1 and below which we classify values into class 2.

ğ‘â‰¥0.5,ğ‘ğ‘™ğ‘ğ‘ ğ‘ =1ğ‘<0.5,ğ‘ğ‘™ğ‘ğ‘ ğ‘ =0
pâ‰¥0.5,class=1p<0.5,class=0
For example, if our threshold was .5 and our prediction function returned .7, we would classify this observation as positive. If our prediction was .2 we would classify the observation as negative. For logistic regression with multiple classes we could select the class with the highest predicted probability.

_images/logistic_regression_sigmoid_w_threshold.png
Making predictions
Using our knowledge of sigmoid functions and decision boundaries, we can now write a prediction function. A prediction function in logistic regression returns the probability of our observation being positive, True, or â€œYesâ€. We call this class 1 and its notation is ğ‘ƒ(ğ‘ğ‘™ğ‘ğ‘ ğ‘ =1)P(class=1). As the probability gets closer to 1, our model is more confident that the observation is in class 1.

Math

Letâ€™s use the same multiple linear regression equation from our linear regression tutorial.

ğ‘§=ğ‘Š0+ğ‘Š1ğ‘†ğ‘¡ğ‘¢ğ‘‘ğ‘–ğ‘’ğ‘‘+ğ‘Š2ğ‘†ğ‘™ğ‘’ğ‘ğ‘¡
z=W0+W1Studied+W2Slept
This time however we will transform the output using the sigmoid function to return a probability value between 0 and 1.

ğ‘ƒ(ğ‘ğ‘™ğ‘ğ‘ ğ‘ =1)=11+ğ‘’âˆ’ğ‘§
P(class=1)=11+eâˆ’z
If the model returns .4 it believes there is only a 40% chance of passing. If our decision boundary was .5, we would categorize this observation as â€œFail.â€â€œ

Code

We wrap the sigmoid function over the same prediction function we used in multiple linear regression

def predict(features, weights):
  '''
  Returns 1D array of probabilities
  that the class label == 1
  '''
  z = np.dot(features, weights)
  return sigmoid(z)
Cost function
Unfortunately we canâ€™t (or at least shouldnâ€™t) use the same cost function MSE (L2) as we did for linear regression. Why? There is a great math explanation in chapter 3 of Michael Neilsonâ€™s deep learning book [5], but for now Iâ€™ll simply say itâ€™s because our prediction function is non-linear (due to sigmoid transform). Squaring this prediction as we do in MSE results in a non-convex function with many local minimums. If our cost function has many local minimums, gradient descent may not find the optimal global minimum.

Math

Instead of Mean Squared Error, we use a cost function called Cross-Entropy, also known as Log Loss. Cross-entropy loss can be divided into two separate cost functions: one for ğ‘¦=1y=1 and one for ğ‘¦=0y=0.

_images/ng_cost_function_logistic.png
The benefits of taking the logarithm reveal themselves when you look at the cost function graphs for y=1 and y=0. These smooth monotonic functions [7] (always increasing or always decreasing) make it easy to calculate the gradient and minimize cost. Image from Andrew Ngâ€™s slides on logistic regression [1].

_images/y1andy2_logistic_function.png
The key thing to note is the cost function penalizes confident and wrong predictions more than it rewards confident and right predictions! The corollary is increasing prediction accuracy (closer to 0 or 1) has diminishing returns on reducing cost due to the logistic nature of our cost function.

Above functions compressed into one

_images/logistic_cost_function_joined.png
Multiplying by ğ‘¦y and (1âˆ’ğ‘¦)(1âˆ’y) in the above equation is a sneaky trick that letâ€™s us use the same equation to solve for both y=1 and y=0 cases. If y=0, the first side cancels out. If y=1, the second side cancels out. In both cases we only perform the operation we need to perform.

Vectorized cost function

_images/logistic_cost_function_vectorized.png
Code

def cost_function(features, labels, weights):
    '''
    Using Mean Absolute Error

    Features:(100,3)
    Labels: (100,1)
    Weights:(3,1)
    Returns 1D matrix of predictions
    Cost = (labels*log(predictions) + (1-labels)*log(1-predictions) ) / len(labels)
    '''
    observations = len(labels)

    predictions = predict(features, weights)

    #Take the error when label=1
    class1_cost = -labels*np.log(predictions)

    #Take the error when label=0
    class2_cost = (1-labels)*np.log(1-predictions)

    #Take the sum of both costs
    cost = class1_cost - class2_cost

    #Take the average cost
    cost = cost.sum() / observations

    return cost
Gradient descent
To minimize our cost, we use Gradient Descent just like before in Linear Regression. There are other more sophisticated optimization algorithms out there such as conjugate gradient like BFGS, but you donâ€™t have to worry about these. Machine learning libraries like Scikit-learn hide their implementations so you can focus on more interesting things!

Math

One of the neat properties of the sigmoid function is its derivative is easy to calculate. If youâ€™re curious, there is a good walk-through derivation on stack overflow [6]. Michael Neilson also covers the topic in chapter 3 of his book.

ğ‘ â€²(ğ‘§)=ğ‘ (ğ‘§)(1âˆ’ğ‘ (ğ‘§))
sâ€²(z)=s(z)(1âˆ’s(z))
Which leads to an equally beautiful and convenient cost function derivative:

ğ¶â€²=ğ‘¥(ğ‘ (ğ‘§)âˆ’ğ‘¦)
Câ€²=x(s(z)âˆ’y)
Note

ğ¶â€²Câ€² is the derivative of cost with respect to weights
ğ‘¦y is the actual class label (0 or 1)
ğ‘ (ğ‘§)s(z) is your modelâ€™s prediction
ğ‘¥x is your feature or feature vector.
Notice how this gradient is the same as the MSE (L2) gradient, the only difference is the hypothesis function.

Pseudocode

Repeat {

  1. Calculate gradient average
  2. Multiply by learning rate
  3. Subtract from weights

}
Code

def update_weights(features, labels, weights, lr):
    '''
    Vectorized Gradient Descent

    Features:(200, 3)
    Labels: (200, 1)
    Weights:(3, 1)
    '''
    N = len(features)

    #1 - Get Predictions
    predictions = predict(features, weights)

    #2 Transpose features from (200, 3) to (3, 200)
    # So we can multiply w the (200,1)  cost matrix.
    # Returns a (3,1) matrix holding 3 partial derivatives --
    # one for each feature -- representing the aggregate
    # slope of the cost function across all observations
    gradient = np.dot(features.T,  predictions - labels)

    #3 Take the average cost derivative for each feature
    gradient /= N

    #4 - Multiply the gradient by our learning rate
    gradient *= lr

    #5 - Subtract from our weights to minimize cost
    weights -= gradient

    return weights
Mapping probabilities to classes
The final step is assign class labels (0 or 1) to our predicted probabilities.

Decision boundary

def decision_boundary(prob):
  return 1 if prob >= .5 else 0
Convert probabilities to classes

def classify(predictions):
  '''
  input  - N element array of predictions between 0 and 1
  output - N element array of 0s (False) and 1s (True)
  '''
  decision_boundary = np.vectorize(decision_boundary)
  return decision_boundary(predictions).flatten()
Example output

Probabilities = [ 0.967, 0.448, 0.015, 0.780, 0.978, 0.004]
Classifications = [1, 0, 0, 1, 1, 0]
Training
Our training code is the same as we used for linear regression.

def train(features, labels, weights, lr, iters):
    cost_history = []

    for i in range(iters):
        weights = update_weights(features, labels, weights, lr)

        #Calculate error for auditing purposes
        cost = cost_function(features, labels, weights)
        cost_history.append(cost)

        # Log Progress
        if i % 1000 == 0:
            print "iter: "+str(i) + " cost: "+str(cost)

    return weights, cost_history
Model evaluation
If our model is working, we should see our cost decrease after every iteration.

iter: 0 cost: 0.635
iter: 1000 cost: 0.302
iter: 2000 cost: 0.264
Final cost: 0.2487. Final weights: [-8.197, .921, .738]

Cost history

_images/logistic_regression_loss_history.png
Accuracy

Accuracy measures how correct our predictions were. In this case we simply compare predicted labels to true labels and divide by the total.

def accuracy(predicted_labels, actual_labels):
    diff = predicted_labels - actual_labels
    return 1.0 - (float(np.count_nonzero(diff)) / len(diff))
Decision boundary

Another helpful technique is to plot the decision boundary on top of our predictions to see how our labels compare to the actual labels. This involves plotting our predicted probabilities and coloring them with their true labels.

_images/logistic_regression_final_decision_boundary.png
Code to plot the decision boundary

def plot_decision_boundary(trues, falses):
    fig = plt.figure()
    ax = fig.add_subplot(111)

    no_of_preds = len(trues) + len(falses)

    ax.scatter([i for i in range(len(trues))], trues, s=25, c='b', marker="o", label='Trues')
    ax.scatter([i for i in range(len(falses))], falses, s=25, c='r', marker="s", label='Falses')

    plt.legend(loc='upper right');
    ax.set_title("Decision Boundary")
    ax.set_xlabel('N/2')
    ax.set_ylabel('Predicted Probability')
    plt.axhline(.5, color='black')
    plt.show()
Multiclass logistic regression
Instead of ğ‘¦=0,1y=0,1 we will expand our definition so that ğ‘¦=0,1...ğ‘›y=0,1...n. Basically we re-run binary classification multiple times, once for each class.

Procedure
Divide the problem into n+1 binary classification problems (+1 because the index starts at 0?).
For each classâ€¦
Predict the probability the observations are in that single class.
prediction = <math>max(probability of the classes)
For each sub-problem, we select one class (YES) and lump all the others into a second class (NO). Then we take the class with the highest predicted value.

Softmax activation
The softmax function (softargmax or normalized exponential function) is a function that takes as input a vector of K real numbers, and normalizes it into a probability distribution consisting of K probabilities proportional to the exponentials of the input numbers. That is, prior to applying softmax, some vector components could be negative, or greater than one; and might not sum to 1; but after applying softmax, each component will be in the interval [ 0 , 1 ] , and the components will add up to 1, so that they can be interpreted as probabilities. The standard (unit) softmax function is defined by the formula

Ïƒ(ğ‘§ğ‘–)=ğ‘’ğ‘§(ğ‘–)âˆ‘ğ¾ğ‘—=1ğ‘’ğ‘§(ğ‘—)   ğ‘“ğ‘œğ‘Ÿ ğ‘–=1,.,.,.,ğ¾ ğ‘ğ‘›ğ‘‘ ğ‘§=ğ‘§1,.,.,.,ğ‘§ğ¾
Ïƒ(zi)=ez(i)âˆ‘j=1Kez(j)   for i=1,.,.,.,K and z=z1,.,.,.,zK
In words: we apply the standard exponential function to each element ğ‘§ğ‘–zi of the input vector ğ‘§z and normalize these values by dividing by the sum of all these exponentials; this normalization ensures that the sum of the components of the output vector Ïƒ(ğ‘§)Ïƒ(z) is 1. [9]

Scikit-Learn example
Letâ€™s compare our performance to the LogisticRegression model provided by scikit-learn [8].

import sklearn
from sklearn.linear_model import LogisticRegression
from sklearn.cross_validation import train_test_split

# Normalize grades to values between 0 and 1 for more efficient computation
normalized_range = sklearn.preprocessing.MinMaxScaler(feature_range=(-1,1))

# Extract Features + Labels
labels.shape =  (100,) #scikit expects this
features = normalized_range.fit_transform(features)

# Create Test/Train
features_train,features_test,labels_train,labels_test = train_test_split(features,labels,test_size=0.4)

# Scikit Logistic Regression
scikit_log_reg = LogisticRegression()
scikit_log_reg.fit(features_train,labels_train)

#Score is Mean Accuracy
scikit_score = clf.score(features_test,labels_test)
print 'Scikit score: ', scikit_score

#Our Mean Accuracy
observations, features, labels, weights = run()
probabilities = predict(features, weights).flatten()
classifications = classifier(probabilities)
our_acc = accuracy(classifications,labels.flatten())
print 'Our score: ',our_acc

You need to know some basic calculus in order to understand how functions change over time (derivatives), and to calculate the total amount of a quantity that accumulates over a time period (integrals). The language of calculus will allow you to speak precisely about the properties of functions and better understand their behaviour.

Normally taking a calculus course involves doing lots of tedious calculations by hand, but having the power of computers on your side can make the process much more fun. This section describes the key ideas of calculus which youâ€™ll need to know to understand machine learning concepts.

Derivatives
A derivative can be defined in two ways:

Instantaneous rate of change (Physics)
Slope of a line at a specific point (Geometry)
Both represent the same principle, but for our purposes itâ€™s easier to explain using the geometric definition.

Geometric definition
In geometry slope represents the steepness of a line. It answers the question: how much does ğ‘¦y or ğ‘“(ğ‘¥)f(x) change given a specific change in ğ‘¥x?

_images/slope_formula.png
Using this definition we can easily calculate the slope between two points. But what if I asked you, instead of the slope between two points, what is the slope at a single point on the line? In this case there isnâ€™t any obvious â€œrise-over-runâ€ to calculate. Derivatives help us answer this question.

A derivative outputs an expression we can use to calculate the instantaneous rate of change, or slope, at a single point on a line. After solving for the derivative you can use it to calculate the slope at every other point on the line.

Taking the derivative
Consider the graph below, where ğ‘“(ğ‘¥)=ğ‘¥2+3f(x)=x2+3.

_images/calculus_slope_intro.png
The slope between (1,4) and (3,12) would be:

ğ‘ ğ‘™ğ‘œğ‘ğ‘’=ğ‘¦2âˆ’ğ‘¦1ğ‘¥2âˆ’ğ‘¥1=12âˆ’43âˆ’1=4
slope=y2âˆ’y1x2âˆ’x1=12âˆ’43âˆ’1=4
But how do we calculate the slope at point (1,4) to reveal the change in slope at that specific point?

One way would be to find the two nearest points, calculate their slopes relative to ğ‘¥x and take the average. But calculus provides an easier, more precise way: compute the derivative. Computing the derivative of a function is essentially the same as our original proposal, but instead of finding the two closest points, we make up an imaginary point an infinitesimally small distance away from ğ‘¥x and compute the slope between ğ‘¥x and the new point.

In this way, derivatives help us answer the question: how does ğ‘“(ğ‘¥)f(x) change if we make a very very tiny increase to x? In other words, derivatives help estimate the slope between two points that are an infinitesimally small distance away from each other. A very, very, very small distance, but large enough to calculate the slope.

In math language we represent this infinitesimally small increase using a limit. A limit is defined as the output value a function approaches as the input value approaches another value. In our case the target value is the specific point at which we want to calculate slope.

Step-by-step
Calculating the derivative is the same as calculating normal slope, however in this case we calculate the slope between our point and a point infinitesimally close to it. We use the variable â„h to represent this infinitesimally distance. Here are the steps:

Given the function:
ğ‘“(ğ‘¥)=ğ‘¥2
f(x)=x2
Increment ğ‘¥x by a very small value â„(â„=Î”ğ‘¥)h(h=Î”x)
ğ‘“(ğ‘¥+â„)=(ğ‘¥+â„)2
f(x+h)=(x+h)2
Apply the slope formula
ğ‘“(ğ‘¥+â„)âˆ’ğ‘“(ğ‘¥)â„
f(x+h)âˆ’f(x)h
Simplify the equation
ğ‘¥2+2ğ‘¥â„+â„2âˆ’ğ‘¥2â„2ğ‘¥â„+â„2â„=2ğ‘¥+â„
x2+2xh+h2âˆ’x2h2xh+h2h=2x+h
Set â„h to 0 (the limit as â„h heads toward 0)
2ğ‘¥+0=2ğ‘¥
2x+0=2x
So what does this mean? It means for the function ğ‘“(ğ‘¥)=ğ‘¥2f(x)=x2, the slope at any point equals 2ğ‘¥2x. The formula is defined as:

limâ„â†’0ğ‘“(ğ‘¥+â„)âˆ’ğ‘“(ğ‘¥)â„
limhâ†’0f(x+h)âˆ’f(x)h
Code

Letâ€™s write code to calculate the derivative of any function ğ‘“(ğ‘¥)f(x). We test our function works as expected on the input ğ‘“(ğ‘¥)=ğ‘¥2f(x)=x2 producing a value close to the actual derivative 2ğ‘¥2x.

def get_derivative(func, x):
    """Compute the derivative of `func` at the location `x`."""
    h = 0.0001                          # step size
    return (func(x+h) - func(x)) / h    # rise-over-run

def f(x): return x**2                   # some test function f(x)=x^2
x = 3                                   # the location of interest
computed = get_derivative(f, x)
actual = 2*x

computed, actual   # = 6.0001, 6        # pretty close if you ask me...
In general itâ€™s preferable to use the math to obtain exact derivative formulas, but keep in mind you can always compute derivatives numerically by computing the rise-over-run for a â€œsmall stepâ€ â„h.

Machine learning use cases
Machine learning uses derivatives in optimization problems. Optimization algorithms like gradient descent use derivatives to decide whether to increase or decrease weights in order to maximize or minimize some objective (e.g. a modelâ€™s accuracy or error functions). Derivatives also help us approximate nonlinear functions as linear functions (tangent lines), which have constant slopes. With a constant slope we can decide whether to move up or down the slope (increase or decrease our weights) to get closer to the target value (class label).

Chain rule
The chain rule is a formula for calculating the derivatives of composite functions. Composite functions are functions composed of functions inside other function(s).

How It Works
Given a composite function ğ‘“(ğ‘¥)=ğ´(ğµ(ğ‘¥))f(x)=A(B(x)), the derivative of ğ‘“(ğ‘¥)f(x) equals the product of the derivative of ğ´A with respect to ğµ(ğ‘¥)B(x) and the derivative of ğµB with respect to ğ‘¥x.

composite function derivative=outer function derivativeâˆ—inner function derivative
composite function derivative=outer function derivativeâˆ—inner function derivative
For example, given a composite function ğ‘“(ğ‘¥)f(x), where:

ğ‘“(ğ‘¥)=â„(ğ‘”(ğ‘¥))
f(x)=h(g(x))
The chain rule tells us that the derivative of ğ‘“(ğ‘¥)f(x) equals:

ğ‘‘ğ‘“ğ‘‘ğ‘¥=ğ‘‘â„ğ‘‘ğ‘”â‹…ğ‘‘ğ‘”ğ‘‘ğ‘¥
dfdx=dhdgâ‹…dgdx
Step-by-step
Say ğ‘“(ğ‘¥)f(x) is composed of two functions â„(ğ‘¥)=ğ‘¥3h(x)=x3 and ğ‘”(ğ‘¥)=ğ‘¥2g(x)=x2. And that:

ğ‘“(ğ‘¥)=â„(ğ‘”(ğ‘¥))=(ğ‘¥2)3
f(x)=h(g(x))=(x2)3
The derivative of ğ‘“(ğ‘¥)f(x) would equal:

ğ‘‘ğ‘“ğ‘‘ğ‘¥=ğ‘‘â„ğ‘‘ğ‘”ğ‘‘ğ‘”ğ‘‘ğ‘¥=ğ‘‘â„ğ‘‘(ğ‘¥2)ğ‘‘ğ‘”ğ‘‘ğ‘¥
dfdx=dhdgdgdx=dhd(x2)dgdx
Steps

Solve for the inner derivative of ğ‘”(ğ‘¥)=ğ‘¥2g(x)=x2
ğ‘‘ğ‘”ğ‘‘ğ‘¥=2ğ‘¥
dgdx=2x
Solve for the outer derivative of â„(ğ‘¥)=ğ‘¥3h(x)=x3, using a placeholder ğ‘b to represent the inner function ğ‘¥2x2
ğ‘‘â„ğ‘‘ğ‘=3ğ‘2
dhdb=3b2
Swap out the placeholder variable (b) for the inner function (g(x))
3(ğ‘¥2)23ğ‘¥4
3(x2)23x4
Return the product of the two derivatives
3ğ‘¥4â‹…2ğ‘¥=6ğ‘¥5
3x4â‹…2x=6x5
Multiple functions
In the above example we assumed a composite function containing a single inner function. But the chain rule can also be applied to higher-order functions like:

ğ‘“(ğ‘¥)=ğ´(ğµ(ğ¶(ğ‘¥)))
f(x)=A(B(C(x)))
The chain rule tells us that the derivative of this function equals:

ğ‘‘ğ‘“ğ‘‘ğ‘¥=ğ‘‘ğ´ğ‘‘ğµğ‘‘ğµğ‘‘ğ¶ğ‘‘ğ¶ğ‘‘ğ‘¥
dfdx=dAdBdBdCdCdx
We can also write this derivative equation ğ‘“â€²fâ€² notation:

ğ‘“â€²=ğ´â€²(ğµ(ğ¶(ğ‘¥))â‹…ğµâ€²(ğ¶(ğ‘¥))â‹…ğ¶â€²(ğ‘¥)
fâ€²=Aâ€²(B(C(x))â‹…Bâ€²(C(x))â‹…Câ€²(x)
Steps

Given the function ğ‘“(ğ‘¥)=ğ´(ğµ(ğ¶(ğ‘¥)))f(x)=A(B(C(x))), lets assume:

ğ´(ğ‘¥)ğµ(ğ‘¥)ğ¶(ğ‘¥)=ğ‘ ğ‘–ğ‘›(ğ‘¥)=ğ‘¥2=4ğ‘¥
A(x)=sin(x)B(x)=x2C(x)=4x
The derivatives of these functions would be:

ğ´â€²(ğ‘¥)ğµâ€²(ğ‘¥)ğ¶â€²(ğ‘¥)=ğ‘ğ‘œğ‘ (ğ‘¥)=2ğ‘¥=4
Aâ€²(x)=cos(x)Bâ€²(x)=2xCâ€²(x)=4
We can calculate the derivative of ğ‘“(ğ‘¥)f(x) using the following formula:

ğ‘“â€²(ğ‘¥)=ğ´â€²((4ğ‘¥)2)â‹…ğµâ€²(4ğ‘¥)â‹…ğ¶â€²(ğ‘¥)
fâ€²(x)=Aâ€²((4x)2)â‹…Bâ€²(4x)â‹…Câ€²(x)
We then input the derivatives and simplify the expression:

ğ‘“â€²(ğ‘¥)=ğ‘ğ‘œğ‘ ((4ğ‘¥)2)â‹…2(4ğ‘¥)â‹…4=ğ‘ğ‘œğ‘ (16ğ‘¥2)â‹…8ğ‘¥â‹…4=ğ‘ğ‘œğ‘ (16ğ‘¥2)32ğ‘¥
fâ€²(x)=cos((4x)2)â‹…2(4x)â‹…4=cos(16x2)â‹…8xâ‹…4=cos(16x2)32x
Gradients
A gradient is a vector that stores the partial derivatives of multivariable functions. It helps us calculate the slope at a specific point on a curve for functions with multiple independent variables. In order to calculate this more complex slope, we need to isolate each variable to determine how it impacts the output on its own. To do this we iterate through each of the variables and calculate the derivative of the function after holding all other variables constant. Each iteration produces a partial derivative which we store in the gradient.

Partial derivatives
In functions with 2 or more variables, the partial derivative is the derivative of one variable with respect to the others. If we change ğ‘¥x, but hold all other variables constant, how does ğ‘“(ğ‘¥,ğ‘§)f(x,z) change? Thatâ€™s one partial derivative. The next variable is ğ‘§z. If we change ğ‘§z but hold ğ‘¥x constant, how does ğ‘“(ğ‘¥,ğ‘§)f(x,z) change? We store partial derivatives in a gradient, which represents the full derivative of the multivariable function.

Step-by-step
Here are the steps to calculate the gradient for a multivariable function:

Given a multivariable function
ğ‘“(ğ‘¥,ğ‘§)=2ğ‘§3ğ‘¥2
f(x,z)=2z3x2
Calculate the derivative with respect to ğ‘¥x
ğ‘‘ğ‘“ğ‘‘ğ‘¥(ğ‘¥,ğ‘§)
dfdx(x,z)
Swap 2ğ‘§32z3 with a constant value ğ‘b
ğ‘“(ğ‘¥,ğ‘§)=ğ‘ğ‘¥2
f(x,z)=bx2
Calculate the derivative with ğ‘b constant
ğ‘‘ğ‘“ğ‘‘ğ‘¥=limâ„â†’0ğ‘“(ğ‘¥+â„)âˆ’ğ‘“(ğ‘¥)â„=limâ„â†’0ğ‘(ğ‘¥+â„)2âˆ’ğ‘(ğ‘¥2)â„=limâ„â†’0ğ‘((ğ‘¥+â„)(ğ‘¥+â„))âˆ’ğ‘ğ‘¥2â„=limâ„â†’0ğ‘((ğ‘¥2+ğ‘¥â„+â„ğ‘¥+â„2))âˆ’ğ‘ğ‘¥2â„=limâ„â†’0ğ‘ğ‘¥2+2ğ‘ğ‘¥â„+ğ‘â„2âˆ’ğ‘ğ‘¥2â„=limâ„â†’02ğ‘ğ‘¥â„+ğ‘â„2â„=limâ„â†’02ğ‘ğ‘¥+ğ‘â„
dfdx=limhâ†’0f(x+h)âˆ’f(x)h=limhâ†’0b(x+h)2âˆ’b(x2)h=limhâ†’0b((x+h)(x+h))âˆ’bx2h=limhâ†’0b((x2+xh+hx+h2))âˆ’bx2h=limhâ†’0bx2+2bxh+bh2âˆ’bx2h=limhâ†’02bxh+bh2h=limhâ†’02bx+bh
As â„â€”>0hâ€”>0â€¦

2bx + 0
Swap 2ğ‘§32z3 back into the equation, to find the derivative with respect to ğ‘¥x.
ğ‘‘ğ‘“ğ‘‘ğ‘¥(ğ‘¥,ğ‘§)=2(2ğ‘§3)ğ‘¥=4ğ‘§3ğ‘¥
dfdx(x,z)=2(2z3)x=4z3x
Repeat the above steps to calculate the derivative with respect to ğ‘§z
ğ‘‘ğ‘“ğ‘‘ğ‘§(ğ‘¥,ğ‘§)=6ğ‘¥2ğ‘§2
dfdz(x,z)=6x2z2
Store the partial derivatives in a gradient
âˆ‡ğ‘“(ğ‘¥,ğ‘§)=[ğ‘‘ğ‘“ğ‘‘ğ‘¥ğ‘‘ğ‘“ğ‘‘ğ‘§]=[4ğ‘§3ğ‘¥6ğ‘¥2ğ‘§2]
âˆ‡f(x,z)=[dfdxdfdz]=[4z3x6x2z2]
Directional derivatives
Another important concept is directional derivatives. When calculating the partial derivatives of multivariable functions we use our old technique of analyzing the impact of infinitesimally small increases to each of our independent variables. By increasing each variable we alter the function output in the direction of the slope.

But what if we want to change directions? For example, imagine weâ€™re traveling north through mountainous terrain on a 3-dimensional plane. The gradient we calculated above tells us weâ€™re traveling north at our current location. But what if we wanted to travel southwest? How can we determine the steepness of the hills in the southwest direction? Directional derivatives help us find the slope if we move in a direction different from the one specified by the gradient.

Math

The directional derivative is computed by taking the dot product [11] of the gradient of ğ‘“f and a unit vector ğ‘£âƒ— vâ†’ of â€œtiny nudgesâ€ representing the direction. The unit vector describes the proportions we want to move in each direction. The output of this calculation is a scalar number representing how much ğ‘“f will change if the current input moves with vector ğ‘£âƒ— vâ†’.

Letâ€™s say you have the function ğ‘“(ğ‘¥,ğ‘¦,ğ‘§)f(x,y,z) and you want to compute its directional derivative along the following vector [2]:

ğ‘£âƒ— =â¡â£â¢â¢23âˆ’1â¤â¦â¥â¥
vâ†’=[23âˆ’1]
As described above, we take the dot product of the gradient and the directional vector:

â¡â£â¢â¢â¢â¢ğ‘‘ğ‘“ğ‘‘ğ‘¥ğ‘‘ğ‘“ğ‘‘ğ‘¦ğ‘‘ğ‘“ğ‘‘ğ‘§â¤â¦â¥â¥â¥â¥â‹…â¡â£â¢â¢23âˆ’1â¤â¦â¥â¥
[dfdxdfdydfdz]â‹…[23âˆ’1]
We can rewrite the dot product as:

âˆ‡ğ‘£âƒ— ğ‘“=2ğ‘‘ğ‘“ğ‘‘ğ‘¥+3ğ‘‘ğ‘“ğ‘‘ğ‘¦âˆ’1ğ‘‘ğ‘“ğ‘‘ğ‘§
âˆ‡vâ†’f=2dfdx+3dfdyâˆ’1dfdz
This should make sense because a tiny nudge along ğ‘£âƒ— vâ†’ can be broken down into two tiny nudges in the x-direction, three tiny nudges in the y-direction, and a tiny nudge backwards, by âˆ’1 in the z-direction.

Useful properties
There are two additional properties of gradients that are especially useful in deep learning. The gradient of a function:

Always points in the direction of greatest increase of a function (explained here)
Is zero at a local maximum or local minimum
Integrals
The integral of ğ‘“(ğ‘¥)f(x) corresponds to the computation of the area under the graph of ğ‘“(ğ‘¥)f(x). The area under ğ‘“(ğ‘¥)f(x) between the points ğ‘¥=ğ‘x=a and ğ‘¥=ğ‘x=b is denoted as follows:

ğ´(ğ‘,ğ‘)=âˆ«ğ‘ğ‘ğ‘“(ğ‘¥)ğ‘‘ğ‘¥.
A(a,b)=âˆ«abf(x)dx.
_images/integral_definition.png
The area ğ´(ğ‘,ğ‘)A(a,b) is bounded by the function ğ‘“(ğ‘¥)f(x) from above, by the ğ‘¥x-axis from below, and by two vertical lines at ğ‘¥=ğ‘x=a and ğ‘¥=ğ‘x=b. The points ğ‘¥=ğ‘x=a and ğ‘¥=ğ‘x=b are called the limits of integration. The âˆ«âˆ« sign comes from the Latin word summa. The integral is the â€œsumâ€ of the values of ğ‘“(ğ‘¥)f(x) between the two limits of integration.

The integral function ğ¹(ğ‘)F(c) corresponds to the area calculation as a function of the upper limit of integration:

ğ¹(ğ‘)â‰¡âˆ«ğ‘0ğ‘“(ğ‘¥)ğ‘‘ğ‘¥.
F(c)â‰¡âˆ«0cf(x)dx.
There are two variables and one constant in this formula. The input variable ğ‘c describes the upper limit of integration. The integration variable ğ‘¥x performs a sweep from ğ‘¥=0x=0 until ğ‘¥=ğ‘x=c. The constant 00 describes the lower limit of integration. Note that choosing ğ‘¥=0x=0 for the starting point of the integral function was an arbitrary choice.

The integral function ğ¹(ğ‘)F(c) contains the â€œprecomputedâ€ information about the area under the graph of ğ‘“(ğ‘¥)f(x). The derivative function ğ‘“â€²(ğ‘¥)fâ€²(x) tells us the â€œslope of the graphâ€ property of the function ğ‘“(ğ‘¥)f(x) for all values of ğ‘¥x. Similarly, the integral function ğ¹(ğ‘)F(c) tells us the â€œarea under the graphâ€ property of the function ğ‘“(ğ‘¥)f(x) for all possible limits of integration.

The area under ğ‘“(ğ‘¥)f(x) between ğ‘¥=ğ‘x=a and ğ‘¥=ğ‘x=b is obtained by calculating the change in the integral function as follows:

ğ´(ğ‘,ğ‘)=âˆ«ğ‘ğ‘ğ‘“(ğ‘¥)ğ‘‘ğ‘¥=ğ¹(ğ‘)âˆ’ğ¹(ğ‘).
A(a,b)=âˆ«abf(x)dx=F(b)âˆ’F(a).
_images/integral_as_change_in_antriderivative.png
Computing integrals
We can approximate the total area under the function ğ‘“(ğ‘¥)f(x) between ğ‘¥=ğ‘x=a and ğ‘¥=ğ‘x=b by splitting the region into tiny vertical strips of width â„h, then adding up the areas of the rectangular strips. The figure below shows how to compute the area under ğ‘“(ğ‘¥)=ğ‘¥2f(x)=x2 between ğ‘¥=1x=1 and ğ‘¥=3x=3 by approximating it as four rectangular strips of width â„=0.5h=0.5.

_images/integral_as_rectangular_strips.png
Usually we want to choose â„h to be a small number so that the approximation is accurate. Here is some sample code that performs integration.

def get_integral(func, a, b):
    """Compute the area under `func` between x=a and x=b."""
    h = 0.0001               # width of small rectangle
    x = a                    # start at x=a
    total = 0
    while x <= b:            # continue until x=b
        total += h*func(x)   # area of rect is base*height
        x += h
    return total

def f(x): return x**2                    # some test function f(x)=x^2
computed = get_integral(f, 1, 3)
def actualF(x): return 1.0/3.0*x**3
actual = actualF(3) - actualF(1)
computed, actual    # = 8.6662, 8.6666   # pretty close if you ask me...
You can find integral functions using the derivative formulas and some reverse engineering. To find an integral function of the function ğ‘“(ğ‘¥)f(x), we must find a function ğ¹(ğ‘¥)F(x) such that ğ¹â€²(ğ‘¥)=ğ‘“(ğ‘¥)Fâ€²(x)=f(x). Suppose youâ€™re given a function ğ‘“(ğ‘¥)f(x) and asked to find its integral function ğ¹(ğ‘¥)F(x):

ğ¹(ğ‘¥)=âˆ«ğ‘“(ğ‘¥)ğ‘‘ğ‘¥.
F(x)=âˆ«f(x)dx.
This problem is equivalent to finding a function ğ¹(ğ‘¥)F(x) whose derivative is ğ‘“(ğ‘¥)f(x):

ğ¹â€²(ğ‘¥)=ğ‘“(ğ‘¥).
Fâ€²(x)=f(x).
For example, suppose you want to find the indefinite integral âˆ«ğ‘¥2ğ‘‘ğ‘¥âˆ«x2dx. We can rephrase this problem as the search for some function ğ¹(ğ‘¥)F(x) such that

ğ¹â€²(ğ‘¥)=ğ‘¥2.
Fâ€²(x)=x2.
Remembering the derivative formulas we saw above, you guess that ğ¹(ğ‘¥)F(x) must contain an ğ‘¥3x3 term. Taking the derivative of a cubic term results in a quadratic term. Therefore, the function you are looking for has the form ğ¹(ğ‘¥)=ğ‘ğ‘¥3F(x)=cx3, for some constant ğ‘c. Pick the constant ğ‘c that makes this equation true:

ğ¹â€²(ğ‘¥)=3ğ‘ğ‘¥2=ğ‘¥2.
Fâ€²(x)=3cx2=x2.
Solving 3ğ‘=13c=1, we find ğ‘=13c=13 and so the integral function is

ğ¹(ğ‘¥)=âˆ«ğ‘¥2ğ‘‘ğ‘¥=13ğ‘¥3+ğ¶.
F(x)=âˆ«x2dx=13x3+C.
You can verify that ğ‘‘ğ‘‘ğ‘¥[13ğ‘¥3+ğ¶]=ğ‘¥2ddx[13x3+C]=x2.

You can also verify Integrals using maths. Here is a set of formulas for your reference

Applications of integration
Integral calculations have widespread applications to more areas of science than are practical to list here. Letâ€™s explore a few examples related to probabilities.

Computing probabilities
A continuous random variable ğ‘‹X is described by its probability density function ğ‘(ğ‘¥)p(x). A probability density function ğ‘(ğ‘¥)p(x) is a positive function for which the total area under the curve is 11:

ğ‘(ğ‘¥)â‰¥0,âˆ€ğ‘¥andâˆ«âˆâˆ’âˆğ‘(ğ‘¥)ğ‘‘ğ‘¥=1.
p(x)â‰¥0,âˆ€xandâˆ«âˆ’âˆâˆp(x)dx=1.
The probability of observing a value of ğ‘‹X between ğ‘a and ğ‘b is given by the integral

Pr(ğ‘â‰¤ğ‘‹â‰¤ğ‘)=âˆ«ğ‘ğ‘ğ‘(ğ‘¥)ğ‘‘ğ‘¥.
Pr(aâ‰¤Xâ‰¤b)=âˆ«abp(x)dx.
Thus, the notion of integration is central to probability theory with continuous random variables.

We also use integration to compute certain characteristic properties of the random variable. The expected value and the variance are two properties of any random variable ğ‘‹X that capture important aspects of its behaviour.

Expected value
The expected value of the random variable ğ‘‹X is computed using the formula

ğœ‡=âˆ«âˆâˆ’âˆğ‘¥ğ‘(ğ‘¥).
Î¼=âˆ«âˆ’âˆâˆxp(x).
The expected value is a single number that tells us what value of ğ‘‹X we can expect to obtain on average from the random variable ğ‘‹X. The expected value is also called the average or the mean of the random variable ğ‘‹X.

Variance
The variance of the random variable ğ‘‹X is defined as follows:

ğœ2=âˆ«âˆâˆ’âˆ(ğ‘¥âˆ’ğœ‡)2ğ‘(ğ‘¥).
Ïƒ2=âˆ«âˆ’âˆâˆ(xâˆ’Î¼)2p(x).
The variance formula computes the expectation of the squared distance of the random variable ğ‘‹X from its expected value. The variance ğœ2Ïƒ2, also denoted var(ğ‘‹)var(X), gives us an indication of how clustered or spread the values of ğ‘‹X are. A small variance indicates the outcomes of ğ‘‹X are tightly clustered near the expected value ğœ‡Î¼, while a large variance indicates the outcomes of ğ‘‹X are widely spread. The square root of the variance is called the standard deviation and is usually denoted ğœÏƒ.

The expected value ğœ‡Î¼ and the variance ğœ2Ïƒ2 are two central concepts in probability theory and statistics because they allow us to characterize any random variable. The expected value is a measure of the central tendency of the random variable, while the variance ğœ2Ïƒ2 measures its dispersion. Readers familiar with concepts from physics can think of the expected value as the centre of mass of the distribution, and the variance as the moment of inertia of the distribution.

Linear algebra is a mathematical toolbox that offers helpful techniques for manipulating groups of numbers simultaneously. It provides structures like vectors and matrices (spreadsheets) to hold these numbers and new rules for how to add, subtract, multiply, and divide them. Here is a brief overview of basic linear algebra concepts taken from my linear algebra post on Medium.

Vectors
Vectors are 1-dimensional arrays of numbers or terms. In geometry, vectors store the magnitude and direction of a potential change to a point. The vector [3, -2] says go right 3 and down 2. A vector with more than one dimension is called a matrix.

Notation
There are a variety of ways to represent vectors. Here are a few you might come across in your reading.

ğ‘£=â¡â£â¢â¢123â¤â¦â¥â¥=â›ââœâœ123ââ âŸâŸ=[123]
v=[123]=(123)=[123]
Vectors in geometry
Vectors typically represent movement from a point. They store both the magnitude and direction of potential changes to a point. The vector [-2,5] says move left 2 units and up 5 units [1].

_images/vectors_geometry.png
A vector can be applied to any point in space. The vectorâ€™s direction equals the slope of the hypotenuse created moving up 5 and left 2. Its magnitude equals the length of the hypotenuse.

Scalar operations
Scalar operations involve a vector and a number. You modify the vector in-place by adding, subtracting, or multiplying the number from all the values in the vector.

â¡â£â¢â¢222â¤â¦â¥â¥+1=â¡â£â¢â¢333â¤â¦â¥â¥
[222]+1=[333]
Elementwise operations
In elementwise operations like addition, subtraction, and division, values that correspond positionally are combined to produce a new vector. The 1st value in vector A is paired with the 1st value in vector B. The 2nd value is paired with the 2nd, and so on. This means the vectors must have equal dimensions to complete the operation.*

[ğ‘1ğ‘2]+[ğ‘1ğ‘2]=[ğ‘1+ğ‘1ğ‘2+ğ‘2]
[a1a2]+[b1b2]=[a1+b1a2+b2]
y = np.array([1,2,3])
x = np.array([2,3,4])
y + x = [3, 5, 7]
y - x = [-1, -1, -1]
y / x = [.5, .67, .75]
See below for details on broadcasting in numpy.

Dot product
The dot product of two vectors is a scalar. Dot product of vectors and matrices (matrix multiplication) is one of the most important operations in deep learning.

[ğ‘1ğ‘2]â‹…[ğ‘1ğ‘2]=ğ‘1ğ‘1+ğ‘2ğ‘2
[a1a2]â‹…[b1b2]=a1b1+a2b2
y = np.array([1,2,3])
x = np.array([2,3,4])
np.dot(y,x) = 20
Hadamard product
Hadamard Product is elementwise multiplication and it outputs a vector.

[ğ‘1ğ‘2]âŠ™[ğ‘1ğ‘2]=[ğ‘1â‹…ğ‘1ğ‘2â‹…ğ‘2]
[a1a2]âŠ™[b1b2]=[a1â‹…b1a2â‹…b2]
y = np.array([1,2,3])
x = np.array([2,3,4])
y * x = [2, 6, 12]
Vector fields
A vector field shows how far the point (x,y) would hypothetically move if we applied a vector function to it like addition or multiplication. Given a point in space, a vector field shows the power and direction of our proposed change at a variety of points in a graph [2].

_images/vector_field.png
This vector field is an interesting one since it moves in different directions depending the starting point. The reason is that the vector behind this field stores terms like 2ğ‘¥2x or ğ‘¥2x2 instead of scalar values like -2 and 5. For each point on the graph, we plug the x-coordinate into 2ğ‘¥2x or ğ‘¥2x2 and draw an arrow from the starting point to the new location. Vector fields are extremely useful for visualizing machine learning techniques like Gradient Descent.

Matrices
A matrix is a rectangular grid of numbers or terms (like an Excel spreadsheet) with special rules for addition, subtraction, and multiplication.

Dimensions
We describe the dimensions of a matrix in terms of rows by columns.

â¡â£â¢â¢25124âˆ’75â¤â¦â¥â¥[ğ‘Â²182ğ‘7ğ‘âˆ’4810]
[245âˆ’7125][aÂ²2a8187aâˆ’410]
The first has dimensions (3,2). The second (2,3).

a = np.array([
 [1,2,3],
 [4,5,6]
])
a.shape == (2,3)
b = np.array([
 [1,2,3]
])
b.shape == (1,3)
Scalar operations
Scalar operations with matrices work the same way as they do for vectors. Simply apply the scalar to every element in the matrixâ€Šâ€”â€Šadd, subtract, divide, multiply, etc.

â¡â£â¢â¢222333â¤â¦â¥â¥+1=â¡â£â¢â¢333444â¤â¦â¥â¥
[232323]+1=[343434]
# Addition
a = np.array(
[[1,2],
 [3,4]])
a + 1
[[2,3],
 [4,5]]
Elementwise operations
In order to add, subtract, or divide two matrices they must have equal dimensions. We combine corresponding values in an elementwise fashion to produce a new matrix.

[ğ‘ğ‘ğ‘ğ‘‘]+[1324]=[ğ‘+1ğ‘+3ğ‘+2ğ‘‘+4]
[abcd]+[1234]=[a+1b+2c+3d+4]
a = np.array([
 [1,2],
 [3,4]])
b = np.array([
 [1,2],
 [3,4]])

a + b
[[2, 4],
 [6, 8]]

a â€” b
[[0, 0],
 [0, 0]]
Hadamard product
Hadamard product of matrices is an elementwise operation. Values that correspond positionally are multiplied to produce a new matrix.

[ğ‘1ğ‘3ğ‘2ğ‘4]âŠ™[ğ‘1ğ‘3ğ‘2ğ‘4]=[ğ‘1â‹…ğ‘1ğ‘3â‹…ğ‘3ğ‘2â‹…ğ‘2ğ‘4â‹…ğ‘4]
[a1a2a3a4]âŠ™[b1b2b3b4]=[a1â‹…b1a2â‹…b2a3â‹…b3a4â‹…b4]
a = np.array(
[[2,3],
 [2,3]])
b = np.array(
[[3,4],
 [5,6]])

# Uses python's multiply operator
a * b
[[ 6, 12],
 [10, 18]]
In numpy you can take the Hadamard product of a matrix and vector as long as their dimensions meet the requirements of broadcasting.

[ğ‘1ğ‘2]âŠ™[ğ‘1ğ‘3ğ‘2ğ‘4]=[ğ‘1â‹…ğ‘1ğ‘2â‹…ğ‘3ğ‘1â‹…ğ‘2ğ‘2â‹…ğ‘4]
[a1a2]âŠ™[b1b2b3b4]=[a1â‹…b1a1â‹…b2a2â‹…b3a2â‹…b4]
Matrix transpose
Neural networks frequently process weights and inputs of different sizes where the dimensions do not meet the requirements of matrix multiplication. Matrix transposition (often denoted by a superscript â€˜Tâ€™ e.g. M^T) provides a way to â€œrotateâ€ one of the matrices so that the operation complies with multiplication requirements and can continue. There are two steps to transpose a matrix:

Rotate the matrix right 90Â°
Reverse the order of elements in each row (e.g. [a b c] becomes [c b a])
As an example, transpose matrix M into T:

â¡â£â¢â¢ğ‘ğ‘ğ‘’ğ‘ğ‘‘ğ‘“â¤â¦â¥â¥â‡’[ğ‘ğ‘ğ‘ğ‘‘ğ‘’ğ‘“]
[abcdef]â‡’[acebdf]
a = np.array([
   [1, 2],
   [3, 4]])

a.T
[[1, 3],
 [2, 4]]
Matrix multiplication
Matrix multiplication specifies a set of rules for multiplying matrices together to produce a new matrix.

Rules

Not all matrices are eligible for multiplication. In addition, there is a requirement on the dimensions of the resulting matrix output. Source.

The number of columns of the 1st matrix must equal the number of rows of the 2nd
The product of an M x N matrix and an N x K matrix is an M x K matrix. The new matrix takes the rows of the 1st and columns of the 2nd
Steps

Matrix multiplication relies on dot product to multiply various combinations of rows and columns. In the image below, taken from Khan Academyâ€™s excellent linear algebra course, each entry in Matrix C is the dot product of a row in matrix A and a column in matrix B [3].

_images/khan_academy_matrix_product.png
The operation a1 Â· b1 means we take the dot product of the 1st row in matrix A (1, 7) and the 1st column in matrix B (3, 5).

ğ‘1â‹…ğ‘1=[17]â‹…[35]=(1â‹…3)+(7â‹…5)=38
a1â‹…b1=[17]â‹…[35]=(1â‹…3)+(7â‹…5)=38
Hereâ€™s another way to look at it:

â¡â£â¢â¢ğ‘ğ‘ğ‘’ğ‘ğ‘‘ğ‘“â¤â¦â¥â¥â‹…[1324]=â¡â£â¢â¢1ğ‘+3ğ‘1ğ‘+3ğ‘‘1ğ‘’+3ğ‘“2ğ‘+4ğ‘2ğ‘+4ğ‘‘2ğ‘’+4ğ‘“â¤â¦â¥â¥
[abcdef]â‹…[1234]=[1a+3b2a+4b1c+3d2c+4d1e+3f2e+4f]
Test yourself
What are the dimensions of the matrix product?
[1526]â‹…[152637]=2 x 3
[1256]â‹…[123567]=2 x 3
What are the dimensions of the matrix product?
â¡â£â¢â¢159261037114812â¤â¦â¥â¥â‹…â¡â£â¢â¢â¢â¢15322601â¤â¦â¥â¥â¥â¥=3 x 2
[123456789101112]â‹…[12563021]=3 x 2
What is the matrix product?
[2134]â‹…[5345]=[19172324]
[2314]â‹…[5435]=[19231724]
What is the matrix product?}
[35]â‹…[123]=[35610915]
[35]â‹…[123]=[36951015]
What is the matrix product?
[123]â‹…â¡â£â¢â¢456â¤â¦â¥â¥=[32]
[123]â‹…[456]=[32]
Numpy
Dot product
Numpy uses the function np.dot(A,B) for both vector and matrix multiplication. It has some other interesting features and gotchas so I encourage you to read the documentation here before use.

a = np.array([
 [1, 2]
 ])
a.shape == (1,2)
b = np.array([
 [3, 4],
 [5, 6]
 ])
b.shape == (2,2)

# Multiply
mm = np.dot(a,b)
mm == [13, 16]
mm.shape == (1,2)
Broadcasting
In numpy the dimension requirements for elementwise operations are relaxed via a mechanism called broadcasting. Two matrices are compatible if the corresponding dimensions in each matrix (rows vs rows, columns vs columns) meet the following requirements:

The dimensions are equal, or
One dimension is of size 1
a = np.array([
 [1],
 [2]
])
b = np.array([
 [3,4],
 [5,6]
])
c = np.array([
 [1,2]
])

# Same no. of rows
# Different no. of columns
# but a has one column so this works
a * b
[[ 3, 4],
 [10, 12]]

# Same no. of columns
# Different no. of rows
# but c has one row so this works
b * c
[[ 3, 8],
 [5, 12]]

# Different no. of columns
# Different no. of rows
# but both a and c meet the
# size 1 requirement rule
a + c
[[2, 3],
 [3, 4]]
 
Algebra
Symbol	Name	Description	Example
(ğ‘“âˆ˜ğ‘”)(fâˆ˜g)	composite function	a nested function	(f âˆ˜ g)(x) = f(g(x))
âˆ†âˆ†	delta	change / difference	âˆ†x = x_1 - x_0
ğ‘’e	Eulerâ€™s number	e = 2.718281828	s = frac{1}{1+e^{-z}}
âˆ‘âˆ‘	summation	sum of all values	âˆ‘ x_i = x_1 + x_2 + x_3
âˆâˆ	capital pi	product of all values	âˆ x_i = x_1âˆ™x_2âˆ™x_3
ğœ–Ïµ	epsilon	tiny number near 0	lr = 1e-4
Calculus
Symbol	Name	Description	Example
ğ‘¥â€²xâ€²	derivative	first derivative	(x^2)â€™ = 2x
ğ‘¥â€³xâ€³	second derivative	second derivative	(x^2)â€™â€™ = 2
limlim	limit	function value as x approaches 0	 
âˆ‡âˆ‡	nabla	gradient	âˆ‡f(a,b,c)
Linear algebra
Symbol	Name	Description	Example
[][]	brackets	matrix or vector	ğ‘€=[135]M=[135]
â‹…â‹…	dot	dot product	(ğ‘=ğ‘‹â‹…ğ‘Š(Z=Xâ‹…W
âŠ™âŠ™	hadamard	hadamard product	ğ´=ğµâŠ™ğ¶A=BâŠ™C
ğ‘‹ğ‘‡XT	transpose	matrix transpose	ğ‘Šğ‘‡â‹…ğ‘‹WTâ‹…X
ğ‘¥âƒ— xâ†’	vector	vector	ğ‘£=[123]v=[123]
ğ‘‹X	matrix	capitalized variables are matrices	ğ‘‹,ğ‘Š,ğµX,W,B
ğ‘¥Ì‚ x^	unit vector	vector of magnitude 1	ğ‘¥Ì‚ =[0.20.50.3]x^=[0.20.50.3]
Probability
Symbol	Name	Description	Example
ğ‘ƒ(ğ´)P(A)	probability	probability of event A	P(x=1) = 0.5
Set theory
Symbol	Name	Description	Example
set	list of distinct elements	S = {1, 5, 7, 9}
Statistics
Symbol	Name	Description	Example
Î¼Î¼	population mean	mean of population values	 
ğ‘¥Â¯xÂ¯	sample mean	mean of subset of population	 
Ïƒ2Ïƒ2	population variance	variance of population value	 
ğ‘ 2s2	sample variance	variance of subset of population	 
Ïƒğ‘‹ÏƒX	standard deviation	population standard deviation	 
ğ‘ s	sample std dev	standard deviation of sample	 
Ïğ‘‹ÏX	correlation	correlation of variables X and Y	 
ğ‘¥Ìƒ x~	median	median value of variable x	 

Neural Network
Neural networks are a class of machine learning algorithms used to model complex patterns in datasets using multiple hidden layers and non-linear activation functions. A neural network takes an input, passes it through multiple layers of hidden neurons (mini-functions with unique coefficients that must be learned), and outputs a prediction representing the combined input of all the neurons.

_images/neural_network_w_matrices.png
Neural networks are trained iteratively using optimization techniques like gradient descent. After each cycle of training, an error metric is calculated based on the difference between prediction and target. The derivatives of this error metric are calculated and propagated back through the network using a technique called backpropagation. Each neuronâ€™s coefficients (weights) are then adjusted relative to how much they contributed to the total error. This process is repeated iteratively until the network error drops below an acceptable threshold.

Neuron
A neuron takes a group of weighted inputs, applies an activation function, and returns an output.

_images/neuron.png
Inputs to a neuron can either be features from a training set or outputs from a previous layerâ€™s neurons. Weights are applied to the inputs as they travel along synapses to reach the neuron. The neuron then applies an activation function to the â€œsum of weighted inputsâ€ from each incoming synapse and passes the result on to all the neurons in the next layer.

Synapse
Synapses are like roads in a neural network. They connect inputs to neurons, neurons to neurons, and neurons to outputs. In order to get from one neuron to another, you have to travel along the synapse paying the â€œtollâ€ (weight) along the way. Each connection between two neurons has a unique synapse with a unique weight attached to it. When we talk about updating weights in a network, weâ€™re really talking about adjusting the weights on these synapses.

Weights
Weights are values that control the strength of the connection between two neurons. That is, inputs are typically multiplied by weights, and that defines how much influence the input will have on the output. In other words: when the inputs are transmitted between neurons, the weights are applied to the inputs along with an additional value (the bias)

Bias
Bias terms are additional constants attached to neurons and added to the weighted input before the activation function is applied. Bias terms help models represent patterns that do not necessarily pass through the origin. For example, if all your features were 0, would your output also be zero? Is it possible there is some base value upon which your features have an effect? Bias terms typically accompany weights and must also be learned by your model.

Layers
_images/neural_network_simple.png
Input Layer

Holds the data your model will train on. Each neuron in the input layer represents a unique attribute in your dataset (e.g. height, hair color, etc.).

Hidden Layer

Sits between the input and output layers and applies an activation function before passing on the results. There are often multiple hidden layers in a network. In traditional networks, hidden layers are typically fully-connected layersâ€Šâ€”â€Šeach neuron receives input from all the previous layerâ€™s neurons and sends its output to every neuron in the next layer. This contrasts with how convolutional layers work where the neurons send their output to only some of the neurons in the next layer.

Output Layer

The final layer in a network. It receives input from the previous hidden layer, optionally applies an activation function, and returns an output representing your modelâ€™s prediction.

Weighted Input
A neuronâ€™s input equals the sum of weighted outputs from all neurons in the previous layer. Each input is multiplied by the weight associated with the synapse connecting the input to the current neuron. If there are 3 inputs or neurons in the previous layer, each neuron in the current layer will have 3 distinct weightsâ€Šâ€”â€Šone for each each synapse.

Single Input

ğ‘=ğ¼ğ‘›ğ‘ğ‘¢ğ‘¡â‹…ğ‘Šğ‘’ğ‘–ğ‘”â„ğ‘¡=ğ‘‹ğ‘Š
Z=Inputâ‹…Weight=XW
Multiple Inputs

ğ‘=âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–ğ‘¤ğ‘–=ğ‘¥1ğ‘¤1+ğ‘¥2ğ‘¤2+ğ‘¥3ğ‘¤3
Z=âˆ‘i=1nxiwi=x1w1+x2w2+x3w3
Notice, itâ€™s exactly the same equation we use with linear regression! In fact, a neural network with a single neuron is the same as linear regression! The only difference is the neural network post-processes the weighted input with an activation function.

Activation Functions
Activation functions live inside neural network layers and modify the data they receive before passing it to the next layer. Activation functions give neural networks their powerâ€Šâ€”â€Šallowing them to model complex non-linear relationships. By modifying inputs with non-linear functions neural networks can model highly complex relationships between features. Popular activation functions include relu and sigmoid.

Activation functions typically have the following properties:

Non-linear - In linear regression weâ€™re limited to a prediction equation that looks like a straight line. This is nice for simple datasets with a one-to-one relationship between inputs and outputs, but what if the patterns in our dataset were non-linear? (e.g. ğ‘¥2x2, sin, log). To model these relationships we need a non-linear prediction equation.Â¹ Activation functions provide this non-linearity.
Continuously differentiableâ€Šâ€”â€ŠTo improve our model with gradient descent, we need our output to have a nice slope so we can compute error derivatives with respect to weights. If our neuron instead outputted 0 or 1 (perceptron), we wouldnâ€™t know in which direction to update our weights to reduce our error.
Fixed Rangeâ€Šâ€”â€ŠActivation functions typically squash the input data into a narrow range that makes training the model more stable and efficient.
Loss Functions
A loss function, or cost function, is a wrapper around our modelâ€™s predict function that tells us â€œhow goodâ€ the model is at making predictions for a given set of parameters. The loss function has its own curve and its own derivatives. The slope of this curve tells us how to change our parameters to make the model more accurate! We use the model to make predictions. We use the cost function to update our parameters. Our cost function can take a variety of forms as there are many different cost functions available. Popular loss functions include: MSE (L2) and Cross-entropy Loss.

Optimization Algorithms
Be the first to contribute!

Gradient Accumulation
Gradient accumulation is a mechanism to split the batch of samplesâ€”used for training a neural networkâ€”into several mini-batches of samples that will be run sequentially.

This is used to enable using large batch sizes that require more GPU memory than available. Gradient accumulation helps in doing so by using mini-batches that require an amount of GPU memory that can be satisfied.

Gradient accumulation means running all mini-batches sequentially (generally on the same GPU) while accumulating their calculated gradients and not updating the model variables - the weights and biases of the model. The model variables must not be updated during the accumulation in order to ensure all mini-batches use the same model variable values to calculate their gradients. Only after accumulating the gradients of all those mini-batches will we generate and apply the updates for the model variables.

This results in the same updates for the model parameters as if we were to use the global batch.

_images/gradient_accumulation.png
More details, a technical and algorithmical deep-dive, how-to tutorials, and examples can be found at [2].

Simple Network
_images/neural_network_simple.png
Forward propagation is how neural networks make predictions. Input data is â€œforward propagatedâ€ through the network layer by layer to the final layer which outputs a prediction. For the toy neural network above, a single pass of forward propagation translates mathematically to:

ğ‘ƒğ‘Ÿğ‘’ğ‘‘ğ‘–ğ‘ğ‘¡ğ‘–ğ‘œğ‘›=ğ´(ğ´(ğ‘‹ğ‘Šâ„)ğ‘Šğ‘œ)
Prediction=A(A(XWh)Wo)
Where ğ´A is an activation function like ReLU, ğ‘‹X is the input and ğ‘Šâ„Wh and ğ‘Šğ‘œWo are weights.

Steps
Calculate the weighted input to the hidden layer by multiplying ğ‘‹X by the hidden weight ğ‘Šâ„Wh
Apply the activation function and pass the result to the final layer
Repeat step 2 except this time ğ‘‹X is replaced by the hidden layerâ€™s output, ğ»H
Code
Letâ€™s write a method feed_forward() to propagate input data through our simple network of 1 hidden layer. The output of this method represents our modelâ€™s prediction.

def relu(z):
    return max(0,z)

def feed_forward(x, Wh, Wo):
    # Hidden layer
    Zh = x * Wh
    H = relu(Zh)

    # Output layer
    Zo = H * Wo
    output = relu(Zo)
    return output
x is the input to the network, Zo and Zh are the weighted inputs and Wo and Wh are the weights.

Larger Network
The simple network above is helpful for learning purposes, but in reality neural networks are much larger and more complex. Modern neural networks have many more hidden layers, more neurons per layer, more variables per input, more inputs per training set, and more output variables to predict. Here is a slightly larger network that will introduce us to matrices and the matrix operations used to train arbitrarily large neural networks.

_images/neural_network_w_matrices.png
Architecture
To accomodate arbitrarily large inputs or outputs, we need to make our code more extensible by adding a few parameters to our networkâ€™s __init__ method: inputLayerSize, hiddenLayerSize, outputLayerSize. Weâ€™ll still limit ourselves to using one hidden layer, but now we can create layers of different sizes to respond to the different inputs or outputs.

INPUT_LAYER_SIZE = 1
HIDDEN_LAYER_SIZE = 2
OUTPUT_LAYER_SIZE = 2
Weight Initialization
Unlike last time where Wh and Wo were scalar numbers, our new weight variables will be numpy arrays. Each array will hold all the weights for its own layerâ€Šâ€”â€Šone weight for each synapse. Below we initialize each array with the numpyâ€™s np.random.randn(rows, cols) method, which returns a matrix of random numbers drawn from a normal distribution with mean 0 and variance 1.

def init_weights():
    Wh = np.random.randn(INPUT_LAYER_SIZE, HIDDEN_LAYER_SIZE) * \
                np.sqrt(2.0/INPUT_LAYER_SIZE)
    Wo = np.random.randn(HIDDEN_LAYER_SIZE, OUTPUT_LAYER_SIZE) * \
                np.sqrt(2.0/HIDDEN_LAYER_SIZE)
Hereâ€™s an example calling random.randn():

arr = np.random.randn(1, 2)

print(arr)
>> [[-0.36094661 -1.30447338]]

print(arr.shape)
>> (1,2)
As youâ€™ll soon see, there are strict requirements on the dimensions of these weight matrices. The number of rows must equal the number of neurons in the previous layer. The number of columns must match the number of neurons in the next layer.

A good explanation of random weight initalization can be found in the Stanford CS231 course notes [1] chapter on neural networks.

Bias Terms
Bias terms allow us to shift our neuronâ€™s activation outputs left and right. This helps us model datasets that do not necessarily pass through the origin.

Using the numpy method np.full() below, we create two 1-dimensional bias arrays filled with the default value 0.2. The first argument to np.full is a tuple of array dimensions. The second is the default value for cells in the array.

def init_bias():
    Bh = np.full((1, HIDDEN_LAYER_SIZE), 0.1)
    Bo = np.full((1, OUTPUT_LAYER_SIZE), 0.1)
    return Bh, Bo
Working with Matrices
To take advantage of fast linear algebra techniques and GPUs, we need to store our inputs, weights, and biases in matrices. Here is our neural network diagram again with its underlying matrix representation.

_images/nn_with_matrices_displayed.png
Whatâ€™s happening here? To better understand, letâ€™s walk through each of the matrices in the diagram with an emphasis on their dimensions and why the dimensions are what they are. The matrix dimensions above flow naturally from the architecture of our network and the number of samples in our training set.

Matrix dimensions

Var	Name	Dimensions	Explanation
X	Input	(3, 1)	Includes 3 rows of training data, and each row has 1 attribute (height, price, etc.)
Wh	Hidden weights	(1, 2)	These dimensions are based on number of rows equals the number of attributes for the observations in our training set. The number columns equals the number of neurons in the hidden layer. The dimensions of the weights matrix between two layers is determined by the sizes of the two layers it connects. There is one weight for every input-to-neuron connection between the layers.
Bh	Hidden bias	(1, 2)	Each neuron in the hidden layer has is own bias constant. This bias matrix is added to the weighted input matrix before the hidden layer applies ReLU.
Zh	Hidden weighted input	(1, 2)	Computed by taking the dot product of X and Wh. The dimensions (1,2) are required by the rules of matrix multiplication. Zh takes the rows of in the inputs matrix and the columns of weights matrix. We then add the hidden layer bias matrix Bh.
H	Hidden activations	(3, 2)	Computed by applying the Relu function to Zh. The dimensions are (3,2)â€Šâ€”â€Šthe number of rows matches the number of training samples and the number of columns equals the number of neurons. Each column holds all the activations for a specific neuron.
Wo	Output weights	(2, 2)	The number of rows matches the number of hidden layer neurons and the number of columns equals the number of output layer neurons. There is one weight for every hidden-neuron-to-output-neuron connection between the layers.
Bo	Output bias	(1, 2)	There is one column for every neuron in the output layer.
Zo	Output weighted input	(3, 2)	Computed by taking the dot product of H and Wo and then adding the output layer bias Bo. The dimensions are (3,2) representing the rows of in the hidden layer matrix and the columns of output layer weights matrix.
O	Output activations	(3, 2)	Each row represents a prediction for a single observation in our training set. Each column is a unique attribute we want to predict. Examples of two-column output predictions could be a companyâ€™s sales and units sold, or a personâ€™s height and weight.
Dynamic Resizing
Before we continue I want to point out how the matrix dimensions change with changes to the network architecture or size of the training set. For example, letâ€™s build a network with 2 input neurons, 3 hidden neurons, 2 output neurons, and 4 observations in our training set.

_images/dynamic_resizing_neural_network_4_obs.png
Now letâ€™s use same number of layers and neurons but reduce the number of observations in our dataset to 1 instance:

_images/dynamic_resizing_neural_network_1_obs.png
As you can see, the number of columns in all matrices remains the same. The only thing that changes is the number of rows the layer matrices, which fluctuate with the size of the training set. The dimensions of the weight matrices remain unchanged. This shows us we can use the same network, the same lines of code, to process any number of observations.

Refactoring Our Code
Here is our new feed forward code which accepts matrices instead of scalar inputs.

def feed_forward(X):
    '''
    X    - input matrix
    Zh   - hidden layer weighted input
    Zo   - output layer weighted input
    H    - hidden layer activation
    y    - output layer
    yHat - output layer predictions
    '''

    # Hidden layer
    Zh = np.dot(X, Wh) + Bh
    H = relu(Zh)

    # Output layer
    Zo = np.dot(H, Wo) + Bo
    yHat = relu(Zo)
    return yHat
Weighted input

The first change is to update our weighted input calculation to handle matrices. Using dot product, we multiply the input matrix by the weights connecting them to the neurons in the next layer. Next we add the bias vector using matrix addition.

Zh = np.dot(X, Wh) + Bh
_images/neural_network_matrix_weighted_input.png
The first column in Bh is added to all the rows in the first column of resulting dot product of X and Wh. The second value in Bh is added to all the elements in the second column. The result is a new matrix, Zh which has a column for every neuron in the hidden layer and a row for every observation in our dataset. Given all the layers in our network are fully-connected, there is one weight for every neuron-to-neuron connection between the layers.

The same process is repeated for the output layer, except the input is now the hidden layer activation H and the weights Wo.

ReLU activation

The second change is to refactor ReLU to use elementwise multiplication on matrices. Itâ€™s only a small change, but its necessary if we want to work with matrices. np.maximum() is actually extensible and can handle both scalar and array inputs.

def relu(Z):
    return np.maximum(0, Z)
In the hidden layer activation step, we apply the ReLU activation function np.maximum(0,Z) to every cell in the new matrix. The result is a matrix where all negative values have been replaced by 0. The same process is repeated for the output layer, except the input is Zo.

Final Result
Putting it all together we have the following code for forward propagation with matrices.

INPUT_LAYER_SIZE = 1
HIDDEN_LAYER_SIZE = 2
OUTPUT_LAYER_SIZE = 2

def init_weights():
    Wh = np.random.randn(INPUT_LAYER_SIZE, HIDDEN_LAYER_SIZE) * \
                np.sqrt(2.0/INPUT_LAYER_SIZE)
    Wo = np.random.randn(HIDDEN_LAYER_SIZE, OUTPUT_LAYER_SIZE) * \
                np.sqrt(2.0/HIDDEN_LAYER_SIZE)


def init_bias():
    Bh = np.full((1, HIDDEN_LAYER_SIZE), 0.1)
    Bo = np.full((1, OUTPUT_LAYER_SIZE), 0.1)
    return Bh, Bo

def relu(Z):
    return np.maximum(0, Z)

def relu_prime(Z):
    '''
    Z - weighted input matrix

    Returns gradient of Z where all
    negative values are set to 0 and
    all positive values set to 1
    '''
    Z[Z < 0] = 0
    Z[Z > 0] = 1
    return Z

def cost(yHat, y):
    cost = np.sum((yHat - y)**2) / 2.0
    return cost

def cost_prime(yHat, y):
    return yHat - y

def feed_forward(X):
    '''
    X    - input matrix
    Zh   - hidden layer weighted input
    Zo   - output layer weighted input
    H    - hidden layer activation
    y    - output layer
    yHat - output layer predictions
    '''

    # Hidden layer
    Zh = np.dot(X, Wh) + Bh
    H = relu(Zh)

    # Output layer
    Zo = np.dot(H, Wo) + Bo
    yHat = relu(Zo)
    
  Backpropagation
Chain rule refresher
Applying the chain rule
Saving work with memoization
Code example
The goals of backpropagation are straightforward: adjust each weight in the network in proportion to how much it contributes to overall error. If we iteratively reduce each weightâ€™s error, eventually weâ€™ll have a series of weights that produce good predictions.

Chain rule refresher
As seen above, foward propagation can be viewed as a long series of nested equations. If you think of feed forward this way, then backpropagation is merely an application of Chain rule to find the Derivatives of cost with respect to any variable in the nested equation. Given a forward propagation function:

ğ‘“(ğ‘¥)=ğ´(ğµ(ğ¶(ğ‘¥)))
f(x)=A(B(C(x)))
A, B, and C are activation functions at different layers. Using the chain rule we easily calculate the derivative of ğ‘“(ğ‘¥)f(x) with respect to ğ‘¥x:

ğ‘“â€²(ğ‘¥)=ğ‘“â€²(ğ´)â‹…ğ´â€²(ğµ)â‹…ğµâ€²(ğ¶)â‹…ğ¶â€²(ğ‘¥)
fâ€²(x)=fâ€²(A)â‹…Aâ€²(B)â‹…Bâ€²(C)â‹…Câ€²(x)
How about the derivative with respect to B? To find the derivative with respect to B you can pretend ğµ(ğ¶(ğ‘¥))B(C(x)) is a constant, replace it with a placeholder variable B, and proceed to find the derivative normally with respect to B.

ğ‘“â€²(ğµ)=ğ‘“â€²(ğ´)â‹…ğ´â€²(ğµ)
fâ€²(B)=fâ€²(A)â‹…Aâ€²(B)
This simple technique extends to any variable within a function and allows us to precisely pinpoint the exact impact each variable has on the total output.

Applying the chain rule
Letâ€™s use the chain rule to calculate the derivative of cost with respect to any weight in the network. The chain rule will help us identify how much each weight contributes to our overall error and the direction to update each weight to reduce our error. Here are the equations we need to make a prediction and calculate total error, or cost:

_images/backprop_ff_equations.png
Given a network consisting of a single neuron, total cost could be calculated as:

ğ¶ğ‘œğ‘ ğ‘¡=ğ¶(ğ‘…(ğ‘(ğ‘‹ğ‘Š)))
Cost=C(R(Z(XW)))
Using the chain rule we can easily find the derivative of Cost with respect to weight W.

ğ¶â€²(ğ‘Š)=ğ¶â€²(ğ‘…)â‹…ğ‘…â€²(ğ‘)â‹…ğ‘â€²(ğ‘Š)=(ğ‘¦Ì‚ âˆ’ğ‘¦)â‹…ğ‘…â€²(ğ‘)â‹…ğ‘‹
Câ€²(W)=Câ€²(R)â‹…Râ€²(Z)â‹…Zâ€²(W)=(y^âˆ’y)â‹…Râ€²(Z)â‹…X
Now that we have an equation to calculate the derivative of cost with respect to any weight, letâ€™s go back to our toy neural network example above

_images/simple_nn_diagram_zo_zh_defined.png
What is the derivative of cost with respect to ğ‘Šğ‘œWo?

ğ¶â€²(ğ‘Šğ‘‚)=ğ¶â€²(ğ‘¦Ì‚ )â‹…ğ‘¦Ì‚ â€²(ğ‘ğ‘‚)â‹…ğ‘â€²ğ‘‚(ğ‘Šğ‘‚)=(ğ‘¦Ì‚ âˆ’ğ‘¦)â‹…ğ‘…â€²(ğ‘ğ‘‚)â‹…ğ»
Câ€²(WO)=Câ€²(y^)â‹…y^â€²(ZO)â‹…ZOâ€²(WO)=(y^âˆ’y)â‹…Râ€²(ZO)â‹…H
And how about with respect to ğ‘Šâ„Wh? To find out we just keep going further back in our function applying the chain rule recursively until we get to the function that has the Wh term.

ğ¶â€²(ğ‘Šâ„)=ğ¶â€²(ğ‘¦Ì‚ )â‹…ğ‘‚â€²(ğ‘ğ‘œ)â‹…ğ‘â€²ğ‘œ(ğ»)â‹…ğ»â€²(ğ‘â„)â‹…ğ‘â€²â„(ğ‘Šâ„)=(ğ‘¦Ì‚ âˆ’ğ‘¦)â‹…ğ‘…â€²(ğ‘ğ‘œ)â‹…ğ‘Šğ‘œâ‹…ğ‘…â€²(ğ‘â„)â‹…ğ‘‹
Câ€²(Wh)=Câ€²(y^)â‹…Oâ€²(Zo)â‹…Zoâ€²(H)â‹…Hâ€²(Zh)â‹…Zhâ€²(Wh)=(y^âˆ’y)â‹…Râ€²(Zo)â‹…Woâ‹…Râ€²(Zh)â‹…X
And just for fun, what if our network had 10 hidden layers. What is the derivative of cost for the first weight ğ‘¤1w1?

ğ¶â€²(ğ‘¤1)=ğ‘‘ğ¶ğ‘‘ğ‘¦Ì‚ â‹…ğ‘‘ğ‘¦Ì‚ ğ‘‘ğ‘11â‹…ğ‘‘ğ‘11ğ‘‘ğ»10â‹…ğ‘‘ğ»10ğ‘‘ğ‘10â‹…ğ‘‘ğ‘10ğ‘‘ğ»9â‹…ğ‘‘ğ»9ğ‘‘ğ‘9â‹…ğ‘‘ğ‘9ğ‘‘ğ»8â‹…ğ‘‘ğ»8ğ‘‘ğ‘8â‹…ğ‘‘ğ‘8ğ‘‘ğ»7â‹…ğ‘‘ğ»7ğ‘‘ğ‘7â‹…ğ‘‘ğ‘7ğ‘‘ğ»6â‹…ğ‘‘ğ»6ğ‘‘ğ‘6â‹…ğ‘‘ğ‘6ğ‘‘ğ»5â‹…ğ‘‘ğ»5ğ‘‘ğ‘5â‹…ğ‘‘ğ‘5ğ‘‘ğ»4â‹…ğ‘‘ğ»4ğ‘‘ğ‘4â‹…ğ‘‘ğ‘4ğ‘‘ğ»3â‹…ğ‘‘ğ»3ğ‘‘ğ‘3â‹…ğ‘‘ğ‘3ğ‘‘ğ»2â‹…ğ‘‘ğ»2ğ‘‘ğ‘2â‹…ğ‘‘ğ‘2ğ‘‘ğ»1â‹…ğ‘‘ğ»1ğ‘‘ğ‘1â‹…ğ‘‘ğ‘1ğ‘‘ğ‘Š1
Câ€²(w1)=dCdy^â‹…dy^dZ11â‹…dZ11dH10â‹…dH10dZ10â‹…dZ10dH9â‹…dH9dZ9â‹…dZ9dH8â‹…dH8dZ8â‹…dZ8dH7â‹…dH7dZ7â‹…dZ7dH6â‹…dH6dZ6â‹…dZ6dH5â‹…dH5dZ5â‹…dZ5dH4â‹…dH4dZ4â‹…dZ4dH3â‹…dH3dZ3â‹…dZ3dH2â‹…dH2dZ2â‹…dZ2dH1â‹…dH1dZ1â‹…dZ1dW1
See the pattern? The number of calculations required to compute cost derivatives increases as our network grows deeper. Notice also the redundancy in our derivative calculations. Each layerâ€™s cost derivative appends two new terms to the terms that have already been calculated by the layers above it. What if there was a way to save our work somehow and avoid these duplicate calculations?

Saving work with memoization
Memoization is a computer science term which simply means: donâ€™t recompute the same thing over and over. In memoization we store previously computed results to avoid recalculating the same function. Itâ€™s handy for speeding up recursive functions of which backpropagation is one. Notice the pattern in the derivative equations below.

_images/memoization.png
Each of these layers is recomputing the same derivatives! Instead of writing out long derivative equations for every weight, we can use memoization to save our work as we backprop error through the network. To do this, we define 3 equations (below), which together encapsulate all the calculations needed for backpropagation. The math is the same, but the equations provide a nice shorthand we can use to track which calculations weâ€™ve already performed and save our work as we move backwards through the network.

_images/backprop_3_equations.png
We first calculate the output layer error and pass the result to the hidden layer before it. After calculating the hidden layer error, we pass its error value back to the previous hidden layer before it. And so on and so forth. As we move back through the network we apply the 3rd formula at every layer to calculate the derivative of cost with respect that layerâ€™s weights. This resulting derivative tells us in which direction to adjust our weights to reduce overall cost.

Note

The term layer error refers to the derivative of cost with respect to a layerâ€™s input. It answers the question: how does the cost function output change when the input to that layer changes?

Output layer error

To calculate output layer error we need to find the derivative of cost with respect to the output layer input, ğ‘ğ‘œZo. It answers the questionâ€Šâ€”â€Šhow are the final layerâ€™s weights impacting overall error in the network? The derivative is then:

ğ¶â€²(ğ‘ğ‘œ)=(ğ‘¦Ì‚ âˆ’ğ‘¦)â‹…ğ‘…â€²(ğ‘ğ‘œ)
Câ€²(Zo)=(y^âˆ’y)â‹…Râ€²(Zo)
To simplify notation, ml practitioners typically replace the (ğ‘¦Ì‚ âˆ’ğ‘¦)âˆ—ğ‘…â€²(ğ‘ğ‘œ)(y^âˆ’y)âˆ—Râ€²(Zo) sequence with the term ğ¸ğ‘œEo. So our formula for output layer error equals:

ğ¸ğ‘œ=(ğ‘¦Ì‚ âˆ’ğ‘¦)â‹…ğ‘…â€²(ğ‘ğ‘œ)
Eo=(y^âˆ’y)â‹…Râ€²(Zo)
Hidden layer error

To calculate hidden layer error we need to find the derivative of cost with respect to the hidden layer input, Zh.

ğ¶â€²(ğ‘â„)=(ğ‘¦Ì‚ âˆ’ğ‘¦)â‹…ğ‘…â€²(ğ‘ğ‘œ)â‹…ğ‘Šğ‘œâ‹…ğ‘…â€²(ğ‘â„)
Câ€²(Zh)=(y^âˆ’y)â‹…Râ€²(Zo)â‹…Woâ‹…Râ€²(Zh)
Next we can swap in the ğ¸ğ‘œEo term above to avoid duplication and create a new simplified equation for Hidden layer error:

ğ¸â„=ğ¸ğ‘œâ‹…ğ‘Šğ‘œâ‹…ğ‘…â€²(ğ‘â„)
Eh=Eoâ‹…Woâ‹…Râ€²(Zh)
This formula is at the core of backpropagation. We calculate the current layerâ€™s error, and pass the weighted error back to the previous layer, continuing the process until we arrive at our first hidden layer. Along the way we update the weights using the derivative of cost with respect to each weight.

Derivative of cost with respect to any weight

Letâ€™s return to our formula for the derivative of cost with respect to the output layer weight ğ‘Šğ‘œWo.

ğ¶â€²(ğ‘Šğ‘‚)=(ğ‘¦Ì‚ âˆ’ğ‘¦)â‹…ğ‘…â€²(ğ‘ğ‘‚)â‹…ğ»
Câ€²(WO)=(y^âˆ’y)â‹…Râ€²(ZO)â‹…H
We know we can replace the first part with our equation for output layer error ğ¸ğ‘œEo. H represents the hidden layer activation.

ğ¶â€²(ğ‘Šğ‘œ)=ğ¸ğ‘œâ‹…ğ»
Câ€²(Wo)=Eoâ‹…H
So to find the derivative of cost with respect to any weight in our network, we simply multiply the corresponding layerâ€™s error times its input (the previous layerâ€™s output).

ğ¶â€²(ğ‘¤)=ğ¶ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡ğ¿ğ‘ğ‘¦ğ‘’ğ‘Ÿğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿâ‹…ğ¶ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡ğ¿ğ‘ğ‘¦ğ‘’ğ‘Ÿğ¼ğ‘›ğ‘ğ‘¢ğ‘¡
Câ€²(w)=CurrentLayerErrorâ‹…CurrentLayerInput
Note

Input refers to the activation from the previous layer, not the weighted input, Z.

Summary

Here are the final 3 equations that together form the foundation of backpropagation.

_images/backprop_final_3_deriv_equations.png
Here is the process visualized using our toy neural network example above.

_images/backprop_visually.png
Code example
def relu_prime(z):
    if z > 0:
        return 1
    return 0

def cost(yHat, y):
    return 0.5 * (yHat - y)**2

def cost_prime(yHat, y):
    return yHat - y

def backprop(x, y, Wh, Wo, lr):
    yHat = feed_forward(x, Wh, Wo)

    # Layer Error
    Eo = (yHat - y) * relu_prime(Zo)
    Eh = Eo * Wo * relu_prime(Zh)

    # Cost derivative for weights
    dWo = Eo * H
    dWh = Eh * x

    # Update weights
    Wh -= lr * dWh
    Wo -= lr * dWo

Linear
A straight line function where activation is proportional to input ( which is the weighted sum from neuron ).

Function	Derivative
ğ‘…(ğ‘§,ğ‘š)={ğ‘§âˆ—ğ‘š}
R(z,m)={zâˆ—m}
ğ‘…â€²(ğ‘§,ğ‘š)={ğ‘š}
Râ€²(z,m)={m}
_images/linear.png	_images/linear_prime.png
def linear(z,m):
	return m*z
def linear_prime(z,m):
	return m
Pros

It gives a range of activations, so it is not binary activation.
We can definitely connect a few neurons together and if more than 1 fires, we could take the max ( or softmax) and decide based on that.
Cons

For this function, derivative is a constant. That means, the gradient has no relationship with X.
It is a constant gradient and the descent is going to be on constant gradient.
If there is an error in prediction, the changes made by back propagation is constant and not depending on the change in input delta(x) !
ELU
Exponential Linear Unit or its widely known name ELU is a function that tend to converge cost to zero faster and produce more accurate results. Different to other activation functions, ELU has a extra alpha constant which should be positive number.

ELU is very similiar to RELU except negative inputs. They are both in identity function form for non-negative inputs. On the other hand, ELU becomes smooth slowly until its output equal to -Î± whereas RELU sharply smoothes.

Function	Derivative
ğ‘…(ğ‘§)={ğ‘§Î±.(ğ‘’ğ‘§â€“1)ğ‘§>0ğ‘§<=0}
R(z)={zz>0Î±.(ezâ€“1)z<=0}
ğ‘…â€²(ğ‘§)={1Î±.ğ‘’ğ‘§ğ‘§>0ğ‘§<0}
Râ€²(z)={1z>0Î±.ezz<0}
_images/elu.png	_images/elu_prime.png
def elu(z,alpha):
	return z if z >= 0 else alpha*(e^z -1)
def elu_prime(z,alpha):
	return 1 if z > 0 else alpha*np.exp(z)
Pros

ELU becomes smooth slowly until its output equal to -Î± whereas RELU sharply smoothes.
ELU is a strong alternative to ReLU.
Unlike to ReLU, ELU can produce negative outputs.
Cons

For x > 0, it can blow up the activation with the output range of [0, inf].
ReLU
A recent invention which stands for Rectified Linear Units. The formula is deceptively simple: ğ‘šğ‘ğ‘¥(0,ğ‘§)max(0,z). Despite its name and appearance, itâ€™s not linear and provides the same benefits as Sigmoid but with better performance.

Function	Derivative
ğ‘…(ğ‘§)={ğ‘§0ğ‘§>0ğ‘§<=0}
R(z)={zz>00z<=0}
ğ‘…â€²(ğ‘§)={10ğ‘§>0ğ‘§<0}
Râ€²(z)={1z>00z<0}
_images/relu.png	_images/relu_prime.png
def relu(z):
  return max(0, z)
def relu_prime(z):
  return 1 if z > 0 else 0
Pros

It avoids and rectifies vanishing gradient problem.
ReLu is less computationally expensive than tanh and sigmoid because it involves simpler mathematical operations.
Cons

One of its limitation is that it should only be used within Hidden layers of a Neural Network Model.
Some gradients can be fragile during training and can die. It can cause a weight update which will makes it never activate on any data point again. Simply saying that ReLu could result in Dead Neurons.
In another words, For activations in the region (x<0) of ReLu, gradient will be 0 because of which the weights will not get adjusted during descent. That means, those neurons which go into that state will stop responding to variations in error/ input ( simply because gradient is 0, nothing changes ). This is called dying ReLu problem.
The range of ReLu is [0, inf). This means it can blow up the activation.
Further reading

Deep Sparse Rectifier Neural Networks Glorot et al., (2011)
Yes You Should Understand Backprop, Karpathy (2016)
LeakyReLU
LeakyRelu is a variant of ReLU. Instead of being 0 when ğ‘§<0z<0, a leaky ReLU allows a small, non-zero, constant gradient ğ›¼Î± (Normally, ğ›¼=0.01Î±=0.01). However, the consistency of the benefit across tasks is presently unclear. [1]

Function	Derivative
ğ‘…(ğ‘§)={ğ‘§ğ›¼ğ‘§ğ‘§>0ğ‘§<=0}
R(z)={zz>0Î±zz<=0}
ğ‘…â€²(ğ‘§)={1ğ›¼ğ‘§>0ğ‘§<0}
Râ€²(z)={1z>0Î±z<0}
_images/leakyrelu.png	_images/leakyrelu_prime.png
def leakyrelu(z, alpha):
	return max(alpha * z, z)
def leakyrelu_prime(z, alpha):
	return 1 if z > 0 else alpha
Pros

Leaky ReLUs are one attempt to fix the â€œdying ReLUâ€ problem by having a small negative slope (of 0.01, or so).
Cons

As it possess linearity, it canâ€™t be used for the complex Classification. It lags behind the Sigmoid and Tanh for some of the use cases.
Further reading

Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification, Kaiming He et al. (2015)
Sigmoid
Sigmoid takes a real value as input and outputs another value between 0 and 1. Itâ€™s easy to work with and has all the nice properties of activation functions: itâ€™s non-linear, continuously differentiable, monotonic, and has a fixed output range.

Function	Derivative
ğ‘†(ğ‘§)=11+ğ‘’âˆ’ğ‘§
S(z)=11+eâˆ’z
ğ‘†â€²(ğ‘§)=ğ‘†(ğ‘§)â‹…(1âˆ’ğ‘†(ğ‘§))
Sâ€²(z)=S(z)â‹…(1âˆ’S(z))
_images/sigmoid.png	_images/sigmoid_prime.png
def sigmoid(z):
  return 1.0 / (1 + np.exp(-z))
def sigmoid_prime(z):
  return sigmoid(z) * (1-sigmoid(z))
Pros

It is nonlinear in nature. Combinations of this function are also nonlinear!
It will give an analog activation unlike step function.
It has a smooth gradient too.
Itâ€™s good for a classifier.
The output of the activation function is always going to be in range (0,1) compared to (-inf, inf) of linear function. So we have our activations bound in a range. Nice, it wonâ€™t blow up the activations then.
Cons

Towards either end of the sigmoid function, the Y values tend to respond very less to changes in X.
It gives rise to a problem of â€œvanishing gradientsâ€.
Its output isnâ€™t zero centered. It makes the gradient updates go too far in different directions. 0 < output < 1, and it makes optimization harder.
Sigmoids saturate and kill gradients.
The network refuses to learn further or is drastically slow ( depending on use case and until gradient /computation gets hit by floating point value limits ).
Further reading

Yes You Should Understand Backprop, Karpathy (2016)
Tanh
Tanh squashes a real-valued number to the range [-1, 1]. Itâ€™s non-linear. But unlike Sigmoid, its output is zero-centered. Therefore, in practice the tanh non-linearity is always preferred to the sigmoid nonlinearity. [1]

Function	Derivative
ğ‘¡ğ‘ğ‘›â„(ğ‘§)=ğ‘’ğ‘§âˆ’ğ‘’âˆ’ğ‘§ğ‘’ğ‘§+ğ‘’âˆ’ğ‘§
tanh(z)=ezâˆ’eâˆ’zez+eâˆ’z
ğ‘¡ğ‘ğ‘›â„â€²(ğ‘§)=1âˆ’ğ‘¡ğ‘ğ‘›â„(ğ‘§)2
tanhâ€²(z)=1âˆ’tanh(z)2
_images/tanh.png	_images/tanh_prime.png
def tanh(z):
	return (np.exp(z) - np.exp(-z)) / (np.exp(z) + np.exp(-z))
def tanh_prime(z):
	return 1 - np.power(tanh(z), 2)
Pros

The gradient is stronger for tanh than sigmoid ( derivatives are steeper).
Cons

Tanh also has the vanishing gradient problem.
Softmax
Softmax function calculates the probabilities distribution of the event over â€˜nâ€™ different events. In general way of saying, this function will calculate the probabilities of each target class over all possible target classes. Later the calculated probabilities will be helpful for determining the target class for the given inputs.

BatchNorm
BatchNorm accelerates convergence by reducing internal covariate shift inside each batch. If the individual observations in the batch are widely different, the gradient updates will be choppy and take longer to converge.

The batch norm layer normalizes the incoming activations and outputs a new batch where the mean equals 0 and standard deviation equals 1. It subtracts the mean and divides by the standard deviation of the batch.

Code

Code example from Agustinus Kristiadi

def BatchNorm():
    # From https://wiseodd.github.io/techblog/2016/07/04/batchnorm/
    # TODO: Add doctring for variable names. Add momentum to init.
    def __init__(self):
        pass

    def forward(self, X, gamma, beta):
        mu = np.mean(X, axis=0)
        var = np.var(X, axis=0)

        X_norm = (X - mu) / np.sqrt(var + 1e-8)
        out = gamma * X_norm + beta

        cache = (X, X_norm, mu, var, gamma, beta)

        return out, cache, mu, var

    def backward(self, dout, cache):
        X, X_norm, mu, var, gamma, beta = cache

        N, D = X.shape

        X_mu = X - mu
        std_inv = 1. / np.sqrt(var + 1e-8)

        dX_norm = dout * gamma
        dvar = np.sum(dX_norm * X_mu, axis=0) * -.5 * std_inv**3
        dmu = np.sum(dX_norm * -std_inv, axis=0) + dvar * np.mean(-2. * X_mu, axis=0)

        dX = (dX_norm * std_inv) + (dvar * 2 * X_mu / N) + (dmu / N)
        dgamma = np.sum(dout * X_norm, axis=0)
        dbeta = np.sum(dout, axis=0)

        return dX, dgamma, dbeta
Further reading

Original Paper
Implementing BatchNorm in Neural Net
Understanding the backward pass through Batch Norm
Convolution
In CNN, a convolution is a linear operation that involves multiplication of weight (kernel/filter) with the input and it does most of the heavy lifting job.

Convolution layer consists of 2 major component 1. Kernel(Filter) 2. Stride

Kernel (Filter): A convolution layer can have more than one filter. The size of the filter should be smaller than the size of input dimension. It is intentional as it allows filter to be applied multiple times at difference point (position) on the input.Filters are helpful in understanding and identifying important features from given input. By applying different filters (more than one filter) on the same input helps in extracting different features from given input. Output from multiplying filter with the input gives Two dimensional array. As such, the output array from this operation is called â€œFeature Mapâ€.
Stride: This property controls the movement of filter over input. when the value is set to 1, then filter moves 1 column at a time over input. When the value is set to 2 then the filer jump 2 columns at a time as filter moves over the input.
Code

# this code demonstate on how Convolution works
# Assume we have a image of 4 X 4 and a filter fo 2 X 2 and Stride = 1

def conv_filter_ouput(input_img_section,filter_value):
      # this method perfromas the multiplication of input and filter
      # returns singular value

      value = 0
      for i in range(len(filter_value)):
            for j in range(len(filter_value[0])):
                  value = value + (input_img_section[i][j]*filter_value[i][j])
      return value

img_input = [[260.745, 261.332, 112.27 , 262.351],
 [260.302, 208.802, 139.05 , 230.709],
 [261.775,  93.73 , 166.118, 122.847],
 [259.56 , 232.038, 262.351, 228.937]]

filter = [[1,0],
   [0,1]]

filterX,filterY = len(filter),len(filter[0])
filtered_result = []
for i in range(0,len(img_mx)-filterX+1):
clm = []
for j in range(0,len(img_mx[0])-filterY+1):
      clm.append(conv_filter_ouput(img_mx[i:i+filterX,j:j+filterY],filter))
filtered_result.append(clm)

print(filtered_result)
_images/cnn_filter_output.png
Further reading

cs231n reference
Dropout
A dropout layer takes the output of the previous layerâ€™s activations and randomly sets a certain fraction (dropout rate) of the activatons to 0, cancelling or â€˜droppingâ€™ them out.

It is a common regularization technique used to prevent overfitting in Neural Networks.

_images/dropout_net.png
The dropout rate is the tunable hyperparameter that is adjusted to measure performance with different values. It is typically set between 0.2 and 0.5 (but may be arbitrarily set).

Dropout is only used during training; At test time, no activations are dropped, but scaled down by a factor of dropout rate. This is to account for more units being active during test time than training time.

For example:

A layer in a neural net outputs a tensor (matrix) A of shape (batch_size, num_features).
The dropout rate of the layer is set to 0.5 (50%).
A random 50% of the values in A will be set to 0.
These will then be multiplied with the weight matrix to form the inputs to the next layer.
The premise behind dropout is to introduce noise into a layer in order to disrupt any interdependent learning or coincidental patterns that may occur between units in the layer, that arenâ€™t significant.

Code

# layer_output is a 2D numpy matrix of activations

layer_output *= np.random.randint(0, high=2, size=layer_output.shape) # dropping out values

# scaling up by dropout rate during TRAINING time, so no scaling needs to be done at test time
layer_output /= 0.5
# OR
layer_output *= 0.5 # Scaling down during TEST time.
[2]	
This results in the following operation.

_images/dropout.png
All reference, images and code examples, unless mentioned otherwise, are from section 4.4.3 of Deep Learning for Python by FranÃ§ois Chollet.

[2]	
Linear
Be the first to contribute!

LSTM
Be the first to contribute!

Pooling
Pooling layers often take convolution layers as input. A complicated dataset with many object will require a large number of filters, each responsible finding pattern in an image so the dimensionally of convolutional layer can get large. It will cause an increase of parameters, which can lead to over-fitting. Pooling layers are methods for reducing this high dimensionally. Just like the convolution layer, there is kernel size and stride. The size of the kernel is smaller than the feature map. For most of the cases the size of the kernel will be 2X2 and the stride of 2. There are mainly two types of pooling layers.

The first type is max pooling layer. Max pooling layer will take a stack of feature maps (convolution layer) as input. The value of the node in the max pooling layer is calculated by just the maximum of the pixels contained in the window.

The other type of pooling layer is the Average Pooling layer. Average pooling layer calculates the average of pixels contained in the window. Its not used often but you may see this used in applications for which smoothing an image is preferable.

Code

def max_pooling(feature_map, size=2, stride=2):
    """
    :param feature_map: Feature matrix of shape (height, width, layers)
    :param size: size of kernal
    :param stride: movement speed of kernal
    :return: max-pooled feature vector
    """
    pool_shape = (feature_map.shape[0]//stride, feature_map.shape[1]//stride, feature_map.shape[-1]) #shape of output
    pool_out = numpy.zeros(pool_shape)
    for layer in range(feature_map.shape[-1]):
            #for each layer
            row = 0
            for r in numpy.arange(0,feature_map.shape[0], stride):
                col = 0
                for c in numpy.arange(0, feature_map.shape[1], stride):
                    pool_out[row, col, layer] = numpy.max([feature_map[c:c+size,  r:r+size, layer]])
                    col = col + 1
                row = row +1
    return pool_out
_images/maxpool.png

Cross-Entropy
Cross-entropy loss, or log loss, measures the performance of a classification model whose output is a probability value between 0 and 1. Cross-entropy loss increases as the predicted probability diverges from the actual label. So predicting a probability of .012 when the actual observation label is 1 would be bad and result in a high loss value. A perfect model would have a log loss of 0.

_images/cross_entropy.png
The graph above shows the range of possible loss values given a true observation (isDog = 1). As the predicted probability approaches 1, log loss slowly decreases. As the predicted probability decreases, however, the log loss increases rapidly. Log loss penalizes both types of errors, but especially those predictions that are confident and wrong!

Cross-entropy and log loss are slightly different depending on context, but in machine learning when calculating error rates between 0 and 1 they resolve to the same thing.

Code

def CrossEntropy(yHat, y):
    if y == 1:
      return -log(yHat)
    else:
      return -log(1 - yHat)
Math

In binary classification, where the number of classes ğ‘€M equals 2, cross-entropy can be calculated as:

âˆ’(ğ‘¦log(ğ‘)+(1âˆ’ğ‘¦)log(1âˆ’ğ‘))
âˆ’(ylogâ¡(p)+(1âˆ’y)logâ¡(1âˆ’p))
If ğ‘€>2M>2 (i.e. multiclass classification), we calculate a separate loss for each class label per observation and sum the result.

âˆ’âˆ‘ğ‘=1ğ‘€ğ‘¦ğ‘œ,ğ‘log(ğ‘ğ‘œ,ğ‘)
âˆ’âˆ‘c=1Myo,clogâ¡(po,c)
Note

M - number of classes (dog, cat, fish)
log - the natural log
y - binary indicator (0 or 1) if class label ğ‘c is the correct classification for observation ğ‘œo
p - predicted probability observation ğ‘œo is of class ğ‘c
Hinge
Used for classification.

Code

def Hinge(yHat, y):
    return np.max(0, 1 - yHat * y)
Huber
Typically used for regression. Itâ€™s less sensitive to outliers than the MSE as it treats error as square only inside an interval.

ğ¿ğ›¿={12(ğ‘¦âˆ’ğ‘¦Ì‚ )2ğ›¿((ğ‘¦âˆ’ğ‘¦Ì‚ )âˆ’12ğ›¿)ğ‘–ğ‘“âˆ£âˆ£(ğ‘¦âˆ’ğ‘¦Ì‚ )âˆ£âˆ£<ğ›¿ğ‘œğ‘¡â„ğ‘’ğ‘Ÿğ‘¤ğ‘–ğ‘ ğ‘’
LÎ´={12(yâˆ’y^)2if|(yâˆ’y^)|<Î´Î´((yâˆ’y^)âˆ’12Î´)otherwise
Code

def Huber(yHat, y, delta=1.):
    return np.where(np.abs(y-yHat) < delta,.5*(y-yHat)**2 , delta*(np.abs(y-yHat)-0.5*delta))
Further information can be found at Huber Loss in Wikipedia.

Kullback-Leibler
Code

def KLDivergence(yHat, y):
    """
    :param yHat:
    :param y:
    :return: KLDiv(yHat || y)
    """
    return np.sum(yHat * np.log((yHat / y)))
MAE (L1)
Mean Absolute Error, or L1 loss. Excellent overview below [6] and [10].

Code

def L1(yHat, y):
    return np.sum(np.absolute(yHat - y))
MSE (L2)
Mean Squared Error, or L2 loss. Excellent overview below [6] and [10].

def MSE(yHat, y):
    return np.sum((yHat - y)**2) / y.size
def MSE_prime(yHat, y):
    return yHat - y
    
Optimizers
What is Optimizer ?

It is very important to tweak the weights of the model during the training process, to make our predictions as correct and optimized as possible. But how exactly do you do that? How do you change the parameters of your model, by how much, and when?

Best answer to all above question is optimizers. They tie together the loss function and model parameters by updating the model in response to the output of the loss function. In simpler terms, optimizers shape and mold your model into its most accurate possible form by futzing with the weights. The loss function is the guide to the terrain, telling the optimizer when itâ€™s moving in the right or wrong direction.

Below are list of example optimizers

Adagrad
Adadelta
Adam
Conjugate Gradients
BFGS
Momentum
Nesterov Momentum
Newtonâ€™s Method
RMSProp
SGD
_images/optimizers.gif
Image Credit: CS231n

Adagrad
Adagrad (short for adaptive gradient) adaptively sets the learning rate according to a parameter.

Parameters that have higher gradients or frequent updates should have slower learning rate so that we do not overshoot the minimum value.
Parameters that have low gradients or infrequent updates should faster learning rate so that they get trained quickly.
It divides the learning rate by the sum of squares of all previous gradients of the parameter.
When the sum of the squared past gradients has a high value, it basically divides the learning rate by a high value, so the learning rate will become less.
Similarly, if the sum of the squared past gradients has a low value, it divides the learning rate by a lower value, so the learning rate value will become high.
This implies that the learning rate is inversely proportional to the sum of the squares of all the previous gradients of the parameter.
ğ‘”ğ‘–ğ‘¡=âˆ‚îˆ¶(ğ‘¤ğ‘–ğ‘¡)âˆ‚ğ‘Šğ‘Š=ğ‘Šâˆ’ğ›¼âˆ‚îˆ¶(ğ‘¤ğ‘–ğ‘¡)âˆ‘ğ‘¡ğ‘Ÿ=1(ğ‘”ğ‘–ğ‘Ÿ)2+ğœ€â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆš
gti=âˆ‚J(wti)âˆ‚WW=Wâˆ’Î±âˆ‚J(wti)âˆ‘r=1t(gri)2+Îµ
Note

ğ‘”ğ‘–ğ‘¡gti - the gradient of a parameter, :math: `Theta ` at an iteration t.
ğ›¼Î± - the learning rate
ğœ–Ïµ - very small value to avoid dividing by zero
def Adagrad(data):
    gradient_sums = np.zeros(theta.shape[0])
    for t in range(num_iterations):
        gradients = compute_gradients(data, weights)
        gradient_sums += gradients ** 2
        gradient_update = gradients / (np.sqrt(gradient_sums + epsilon))
        weights = weights - lr * gradient_update
    return weights
Adadelta
AdaDelta belongs to the family of stochastic gradient descent algorithms, that provide adaptive techniques for hyperparameter tuning. Adadelta is probably short for â€˜adaptive deltaâ€™, where delta here refers to the difference between the current weight and the newly updated weight.

The main disadvantage in Adagrad is its accumulation of the squared gradients. During the training process, the accumulated sum keeps growing. From the above formala we can see that, As the accumulated sum increases learning rate to shrink and eventually become infinitesimally small, at which point the algorithm is no longer able to acquire additional knowledge.

Adadelta is a more robust extension of Adagrad that adapts learning rates based on a moving window of gradient updates, instead of accumulating all past gradients. This way, Adadelta continues learning even when many updates have been done.

With Adadelta, we do not even need to set a default learning rate, as it has been eliminated from the update rule.

Implementation is something like this,

ğ‘£ğ‘¡=ğœŒğ‘£ğ‘¡âˆ’1+(1âˆ’ğœŒ)âˆ‡2ğœƒğ½(ğœƒ)Î”ğœƒğœƒğ‘¤ğ‘¡=ğœŒğ‘¤ğ‘¡âˆ’1+(1âˆ’ğœŒ)Î”ğœƒ2=ğ‘¤ğ‘¡+ğœ–â€¾â€¾â€¾â€¾â€¾â€¾âˆšğ‘£ğ‘¡+ğœ–â€¾â€¾â€¾â€¾â€¾â€¾âˆšâˆ‡ğœƒğ½(ğœƒ)=ğœƒâˆ’ğœ‚Î”ğœƒ
vt=Ïvtâˆ’1+(1âˆ’Ï)âˆ‡Î¸2J(Î¸)Î”Î¸=wt+Ïµvt+Ïµâˆ‡Î¸J(Î¸)Î¸=Î¸âˆ’Î·Î”Î¸wt=Ïwtâˆ’1+(1âˆ’Ï)Î”Î¸2
def Adadelta(weights, sqrs, deltas, rho, batch_size):
    eps_stable = 1e-5
    for weight, sqr, delta in zip(weights, sqrs, deltas):
        g = weight.grad / batch_size
        sqr[:] = rho * sqr + (1. - rho) * nd.square(g)
        cur_delta = nd.sqrt(delta + eps_stable) / nd.sqrt(sqr + eps_stable) * g
        delta[:] = rho * delta + (1. - rho) * cur_delta * cur_delta
        # update weight in place.
        weight[:] -= cur_delta
Adam
Adaptive Moment Estimation (Adam) combines ideas from both RMSProp and Momentum. It computes adaptive learning rates for each parameter and works as follows.

First, it computes the exponentially weighted average of past gradients (ğ‘£ğ‘‘ğ‘ŠvdW).
Second, it computes the exponentially weighted average of the squares of past gradients (ğ‘ ğ‘‘ğ‘ŠsdW).
Third, these averages have a bias towards zero and to counteract this a bias correction is applied (ğ‘£ğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ğ‘‘ğ‘ŠvdWcorrected, ğ‘ ğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ğ‘‘ğ‘ŠsdWcorrected).
Lastly, the parameters are updated using the information from the calculated averages.
ğ‘£ğ‘‘ğ‘Š=ğ›½1ğ‘£ğ‘‘ğ‘Š+(1âˆ’ğ›½1)âˆ‚îˆ¶âˆ‚ğ‘Šğ‘ ğ‘‘ğ‘Š=ğ›½2ğ‘ ğ‘‘ğ‘Š+(1âˆ’ğ›½2)(âˆ‚îˆ¶âˆ‚ğ‘Š)2ğ‘£ğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ğ‘‘ğ‘Š=ğ‘£ğ‘‘ğ‘Š1âˆ’(ğ›½1)ğ‘¡ğ‘ ğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ğ‘‘ğ‘Š=ğ‘ ğ‘‘ğ‘Š1âˆ’(ğ›½1)ğ‘¡ğ‘Š=ğ‘Šâˆ’ğ›¼ğ‘£ğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ğ‘‘ğ‘Šğ‘ ğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ğ‘‘ğ‘Šâ€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆš+ğœ€
vdW=Î²1vdW+(1âˆ’Î²1)âˆ‚Jâˆ‚WsdW=Î²2sdW+(1âˆ’Î²2)(âˆ‚Jâˆ‚W)2vdWcorrected=vdW1âˆ’(Î²1)tsdWcorrected=sdW1âˆ’(Î²1)tW=Wâˆ’Î±vdWcorrectedsdWcorrected+Îµ
Note

ğ‘£ğ‘‘ğ‘ŠvdW - the exponentially weighted average of past gradients
ğ‘ ğ‘‘ğ‘ŠsdW - the exponentially weighted average of past squares of gradients
ğ›½1Î²1 - hyperparameter to be tuned
ğ›½2Î²2 - hyperparameter to be tuned
âˆ‚îˆ¶âˆ‚ğ‘Šâˆ‚Jâˆ‚W - cost gradient with respect to current layer
ğ‘ŠW - the weight matrix (parameter to be updated)
ğ›¼Î± - the learning rate
ğœ–Ïµ - very small value to avoid dividing by zero
Conjugate Gradients
Be the first to contribute!

BFGS
Be the first to contribute!

Momentum
Used in conjunction Stochastic Gradient Descent (sgd) or Mini-Batch Gradient Descent, Momentum takes into account past gradients to smooth out the update. This is seen in variable ğ‘£v which is an exponentially weighted average of the gradient on previous steps. This results in minimizing oscillations and faster convergence.

ğ‘£ğ‘‘ğ‘Š=ğ›½ğ‘£ğ‘‘ğ‘Š+(1âˆ’ğ›½)âˆ‚îˆ¶âˆ‚ğ‘Šğ‘Š=ğ‘Šâˆ’ğ›¼ğ‘£ğ‘‘ğ‘Š
vdW=Î²vdW+(1âˆ’Î²)âˆ‚Jâˆ‚WW=Wâˆ’Î±vdW
Note

ğ‘£v - the exponentially weighted average of past gradients
âˆ‚îˆ¶âˆ‚ğ‘Šâˆ‚Jâˆ‚W - cost gradient with respect to current layer weight tensor
ğ‘ŠW - weight tensor
ğ›½Î² - hyperparameter to be tuned
ğ›¼Î± - the learning rate
Nesterov Momentum
Be the first to contribute!

Newtonâ€™s Method
Be the first to contribute!

RMSProp
Another adaptive learning rate optimization algorithm, Root Mean Square Prop (RMSProp) works by keeping an exponentially weighted average of the squares of past gradients. RMSProp then divides the learning rate by this average to speed up convergence.

ğ‘ ğ‘‘ğ‘Š=ğ›½ğ‘ ğ‘‘ğ‘Š+(1âˆ’ğ›½)(âˆ‚îˆ¶âˆ‚ğ‘Š)2ğ‘Š=ğ‘Šâˆ’ğ›¼âˆ‚îˆ¶âˆ‚ğ‘Šğ‘ ğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ğ‘‘ğ‘Šâ€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆš+ğœ€
sdW=Î²sdW+(1âˆ’Î²)(âˆ‚Jâˆ‚W)2W=Wâˆ’Î±âˆ‚Jâˆ‚WsdWcorrected+Îµ
Note

ğ‘ s - the exponentially weighted average of past squares of gradients
âˆ‚îˆ¶âˆ‚ğ‘Šâˆ‚Jâˆ‚W - cost gradient with respect to current layer weight tensor
ğ‘ŠW - weight tensor
ğ›½Î² - hyperparameter to be tuned
ğ›¼Î± - the learning rate
ğœ–Ïµ - very small value to avoid dividing by zero
SGD
SGD stands for Stochastic Gradient Descent.In Stochastic Gradient Descent, a few samples are selected randomly instead of the whole data set for each iteration. In Gradient Descent, there is a term called â€œbatchâ€ which denotes the total number of samples from a dataset that is used for calculating the gradient for each iteration. In typical Gradient Descent optimization, like Batch Gradient Descent, the batch is taken to be the whole dataset. Although, using the whole dataset is really useful for getting to the minima in a less noisy or less random manner, but the problem arises when our datasets get really huge.

This problem is solved by Stochastic Gradient Descent. In SGD, it uses only a single sample to perform each iteration. The sample is randomly shuffled and selected for performing the iteration.

Since only one sample from the dataset is chosen at random for each iteration, the path taken by the algorithm to reach the minima is usually noisier than your typical Gradient Descent algorithm. But that doesnâ€™t matter all that much because the path taken by the algorithm does not matter, as long as we reach the minima and with significantly shorter training time.

def SGD(data, batch_size, lr):
    N = len(data)
    np.random.shuffle(data)
    mini_batches = np.array([data[i:i+batch_size]
     for i in range(0, N, batch_size)])
    for X,y in mini_batches:
        backprop(X, y, lr)
        
Regularization
Data Augmentation
Dropout
Early Stopping
Ensembling
Injecting Noise
L1 Regularization
L2 Regularization
What is overfitting?

From Wikipedia overfitting is,

The production of an analysis that corresponds too closely or exactly to a particular set of data, and may therefore fail to fit additional data or predict future observations reliably

What is Regularization?

It is a Techniques for combating overfitting and improving training.

Data Augmentation
Having more data (dataset / samples) is a best way to get better consistent estimators (ML model). In the real world getting a large volume of useful data for training a model is cumbersome and labelling is an extremely tedious task.

Either labelling requires more manual annotation, example - For creating a better image classifier we can use Mturk and involve more man power to generate dataset or doing survey in social media and asking people to participate and generate dataset. Above process can yield good dataset however those are difficult to carry and expensive. Having small dataset will lead to the well know Over fitting problem.

Data Augmentation is one of the interesting regularization technique to resolve the above problem. The concept is very simple, this technique generates new training data from given original dataset. Dataset Augmentation provides a cheap and easy way to increase the amount of your training data.

This technique can be used for both NLP and CV.

In CV we can use the techniques like Jitter, PCA and Flipping. Similarly in NLP we can use the techniques like Synonym Replacement,Random Insertion, Random Deletion and Word Embeddings.

It is worth knowing that Kerasâ€™ provided ImageDataGenerator for generating Data Augmentation.

Sample code for random deletion

def random_deletion(words, p):
        """
        Randomly delete words from the sentence with probability p
        """

        #obviously, if there's only one word, don't delete it
        if len(words) == 1:
                return words

        #randomly delete words with probability p
        new_words = []
        for word in words:
                r = random.uniform(0, 1)
                if r > p:
                        new_words.append(word)

        #if you end up deleting all words, just return a random word
        if len(new_words) == 0:
                rand_int = random.randint(0, len(words)-1)
                return [words[rand_int]]

        return new_words
Furthermore, when comparing two machine learning algorithms train both with either augmented or non-augmented dataset. Otherwise, no subjective decision can be made on which algorithm performed better

Further reading

NLP Data Augmentation
CV Data Augmentation
Regularization
Dropout
What is Dropout?

Dropout is a regularization technique for reducing overfitting in neural networks by preventing complex co-adaptations on training data

Dropout is a technique where randomly selected neurons are ignored during training. They are â€œdropped-outâ€ randomly. This means that their contribution to the activation of downstream neurons is temporally removed on the forward pass and any weight updates are not applied to the neuron on the backward pass.

Simply put, It is the process of ignoring some of the neurons in particular forward or backward pass.

Dropout can be easily implemented by randomly selecting nodes to be dropped-out with a given probability (e.g. .1%) each weight update cycle.

Most importantly Dropout is only used during the training of a model and is not used when evaluating the model.

_images/regularization-dropout.PNG
image from https://www.cs.toronto.edu/~hinton/absps/JMLRdropout.pdf

import numpy as np
A = np.arange(20).reshape((5,4))

print("Given input: ")
print(A)

def dropout(X, drop_probability):
    keep_probability = 1 - drop_probability
    mask = np.random.uniform(0, 1.0, X.shape) < keep_probability
    if keep_probability > 0.0:
        scale = (1/keep_probability)
    else:
        scale = 0.0
    return mask * X * scale

print("\n After Dropout: ")
print(dropout(A,0.5))
output from above code

Given input:
[[ 0  1  2  3]
[ 4  5  6  7]
[ 8  9 10 11]
[12 13 14 15]
[16 17 18 19]]

After Dropout:
[[ 0.  2.  0.  0.]
[ 8.  0.  0. 14.]
[16. 18.  0. 22.]
[24.  0.  0.  0.]
[32. 34. 36.  0.]]
Further reading

Dropout https://www.cs.toronto.edu/~hinton/absps/JMLRdropout.pdf
Early Stopping
One of the biggest problem in training neural network is how long to train the model.

Training too little will lead to underfit in train and test sets. Traning too much will have the overfit in training set and poor result in test sets.

Here the challenge is to train the network long enough that it is capable of learning the mapping from inputs to outputs, but not training the model so long that it overfits the training data.

One possible solution to solve this problem is to treat the number of training epochs as a hyperparameter and train the model multiple times with different values, then select the number of epochs that result in the best accuracy on the train or a holdout test dataset, But the problem is it requires multiple models to be trained and discarded.

_images/earlystopping.png
Clearly, after â€˜tâ€™ epochs, the model starts overfitting. This is clear by the increasing gap between the train and the validation error in the above plot.

One alternative technique to prevent overfitting is use validation error to decide when to stop. This approach is called Early Stopping.

While building the model, it is evaluated on the holdout validation dataset after each epoch. If the accuracy of the model on the validation dataset starts to degrade (e.g. loss begins to increase or accuracy begins to decrease), then the training process is stopped. This process is called Early stopping.

Python implementation for Early stopping,

def early_stopping(theta0, (x_train, y_train), (x_valid, y_valid), n = 1, p = 100):
  """ The early stopping meta-algorithm for determining the best amount of time to train.
      REF: Algorithm 7.1 in deep learning book.

      Parameters:
      n: int; Number of steps between evaluations.
      p: int; "patience", the number of evaluations to observe worsening validataion set.
      theta0: Network; initial network.
      x_train: iterable; The training input set.
      y_train: iterable; The training output set.
      x_valid: iterable; The validation input set.
      y_valid: iterable; The validation output set.

      Returns:
      theta_prime: Network object; The output network.
      i_prime: int; The number of iterations for the output network.
      v: float; The validation error for the output network.
  """
  # Initialize variables
  theta = theta0.clone()       # The active network
  i = 0                        # The number of training steps taken
  j = 0                        # The number of evaluations steps since last update of theta_prime
  v = np.inf                   # The best evaluation error observed thusfar
  theta_prime = theta.clone()  # The best network found thusfar
  i_prime = i                  # The index of theta_prime

  while j < p:
      # Update theta by running the training algorithm for n steps
      for _ in range(n):
          theta.train(x_train, y_train)

      # Update Values
      i += n
      v_new = theta.error(x_valid, y_valid)

      # If better validation error, then reset waiting time, save the network, and update the best error value
      if v_new < v:
          j = 0
          theta_prime = theta.clone()
          i_prime = i
          v = v_new

      # Otherwise, update the waiting time
      else:
          j += 1

  return theta_prime, i_prime, v
Further reading

Regularization
Ensembling
Ensemble methods combine several machine learning techniques into one predictive model. There are a few different methods for ensembling, but the two most common are:

Bagging

Bagging stands for bootstrap aggregation. One way to reduce the variance of an estimate is to average together multiple estimates.
It trains a large number of â€œstrongâ€ learners in parallel.
A strong learner is a model thatâ€™s relatively unconstrained.
Bagging then combines all the strong learners together in order to â€œsmooth outâ€ their predictions.
Boosting

Boosting refers to a family of algorithms that are able to convert weak learners to strong learners.
Each one in the sequence focuses on learning from the mistakes of the one before it.
Boosting then combines all the weak learners into a single strong learner.
Bagging uses complex base models and tries to â€œsmooth outâ€ their predictions, while boosting uses simple base models and tries to â€œboostâ€ their aggregate complexity.

Injecting Noise
Noise is often introduced to the inputs as a dataset augmentation strategy. When we have a small dataset the network may effectively memorize the training dataset. Instead of learning a general mapping from inputs to outputs, the model may learn the specific input examples and their associated outputs. One approach for improving generalization error and improving the structure of the mapping problem is to add random noise.

Adding noise means that the network is less able to memorize training samples because they are changing all of the time, resulting in smaller network weights and a more robust network that has lower generalization error.

Noise is only added during training. No noise is added during the evaluation of the model or when the model is used to make predictions on new data.

Random noise can be added to other parts of the network during training. Some examples include:

Noise Injection on Weights

Noise added to weights can be interpreted as a more traditional form of regularization.
In other words, it pushes the model to be relatively insensitive to small variations in the weights, finding points that are not merely minima, but minima surrounded by flat regions.
Noise Injection on Outputs

In the real world dataset, We can expect some amount of mistakes in the output labels. One way to remedy this is to explicitly model the noise on labels.
An example for Noise Injection on Outputs is label smoothing
Further reading

Regularization
L1 Regularization
A regression model that uses L1 regularization technique is called Lasso Regression.

Mathematical formula for L1 Regularization.

Letâ€™s define a model to see how L1 Regularization works. For simplicity, We define a simple linear regression model Y with one independent variable.

In this model, W represent Weight, b represent Bias.

ğ‘Š=ğ‘¤1,ğ‘¤2...ğ‘¤ğ‘›ğ‘‹=ğ‘¥1,ğ‘¥2...ğ‘¥ğ‘›
W=w1,w2...wnX=x1,x2...xn
and the predicted result is ğ‘ŒË†Y^

ğ‘ŒË†=ğ‘¤1ğ‘¥1+ğ‘¤2ğ‘¥2+...ğ‘¤ğ‘›ğ‘¥ğ‘›+ğ‘
Y^=w1x1+w2x2+...wnxn+b
Following formula calculates the error without Regularization function

ğ¿ğ‘œğ‘ ğ‘ =ğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(ğ‘Œ,ğ‘ŒË†)
Loss=Error(Y,Y^)
Following formula calculates the error With L1 Regularization function

ğ¿ğ‘œğ‘ ğ‘ =ğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(ğ‘Œâˆ’ğ‘ŒË†)+ğœ†âˆ‘1ğ‘›|ğ‘¤ğ‘–|
Loss=Error(Yâˆ’Y^)+Î»âˆ‘1n|wi|
Note

Here, If the value of lambda is Zero then above Loss function becomes Ordinary Least Square whereas very large value makes the coefficients (weights) zero hence it under-fits.

One thing to note is that |ğ‘¤||w| is differentiable when w!=0 as shown below,

d|ğ‘¤|dğ‘¤={1âˆ’1ğ‘¤>0ğ‘¤<0
d|w|dw={1w>0âˆ’1w<0
To understand the Note above,

Letâ€™s substitute the formula in finding new weights using Gradient Descent optimizer.

ğ‘¤ğ‘›ğ‘’ğ‘¤=ğ‘¤âˆ’ğœ‚âˆ‚ğ¿1âˆ‚ğ‘¤
wnew=wâˆ’Î·âˆ‚L1âˆ‚w
When we apply the L1 in above formula it becomes,

ğ‘¤ğ‘›ğ‘’ğ‘¤=ğ‘¤âˆ’ğœ‚.(ğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(ğ‘Œ,ğ‘ŒË†)+ğœ†d|ğ‘¤|dğ‘¤)={ğ‘¤âˆ’ğœ‚.(ğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(ğ‘Œ,ğ‘ŒË†)+ğœ†)ğ‘¤âˆ’ğœ‚.(ğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(ğ‘Œ,ğ‘ŒË†)âˆ’ğœ†)ğ‘¤>0ğ‘¤<0
wnew=wâˆ’Î·.(Error(Y,Y^)+Î»d|w|dw)={wâˆ’Î·.(Error(Y,Y^)+Î»)w>0wâˆ’Î·.(Error(Y,Y^)âˆ’Î»)w<0
From the above formula,

If w is positive, the regularization parameter ğœ†Î» > 0 will push w to be less positive, by subtracting ğœ†Î» from w.
If w is negative, the regularization parameter ğœ†Î» < 0 will push w to be less negative, by adding ğœ†Î» to w. hence this has the effect of pushing w towards 0.
Simple python implementation

def update_weights_with_l1_regularization(features, targets, weights, lr,lambda):
     '''
     Features:(200, 3)
     Targets: (200, 1)
     Weights:(3, 1)
     '''
     predictions = predict(features, weights)

     #Extract our features
     x1 = features[:,0]
     x2 = features[:,1]
     x3 = features[:,2]

     # Use matrix cross product (*) to simultaneously
     # calculate the derivative for each weight
     d_w1 = -x1*(targets - predictions)
     d_w2 = -x2*(targets - predictions)
     d_w3 = -x3*(targets - predictions)

     # Multiply the mean derivative by the learning rate
     # and subtract from our weights (remember gradient points in direction of steepest ASCENT)

     weights[0][0] = (weights[0][0] - lr * np.mean(d_w1) - lambda) if weights[0][0] > 0 else (weights[0][0] - lr * np.mean(d_w1) + lambda)
     weights[1][0] = (weights[1][0] - lr * np.mean(d_w2) - lambda) if weights[1][0] > 0 else (weights[1][0] - lr * np.mean(d_w2) + lambda)
     weights[2][0] = (weights[2][0] - lr * np.mean(d_w3) - lambda) if weights[2][0] > 0 else (weights[2][0] - lr * np.mean(d_w3) + lambda)

     return weights
Use Case

L1 Regularization (or varient of this concept) is a model of choice when the number of features are high, Since it provides sparse solutions. We can get computational advantage as the features with zero coefficients can simply be ignored.

Further reading

Linear Regression
L2 Regularization
A regression model that uses L2 regularization technique is called Ridge Regression. Main difference between L1 and L2 regularization is, L2 regularization uses â€œsquared magnitudeâ€ of coefficient as penalty term to the loss function.

Mathematical formula for L2 Regularization.

Letâ€™s define a model to see how L2 Regularization works. For simplicity, We define a simple linear regression model Y with one independent variable.

In this model, W represent Weight, b represent Bias.

ğ‘Š=ğ‘¤1,ğ‘¤2...ğ‘¤ğ‘›ğ‘‹=ğ‘¥1,ğ‘¥2...ğ‘¥ğ‘›
W=w1,w2...wnX=x1,x2...xn
and the predicted result is ğ‘ŒË†Y^

ğ‘ŒË†=ğ‘¤1ğ‘¥1+ğ‘¤2ğ‘¥2+...ğ‘¤ğ‘›ğ‘¥ğ‘›+ğ‘
Y^=w1x1+w2x2+...wnxn+b
Following formula calculates the error without Regularization function

ğ¿ğ‘œğ‘ ğ‘ =ğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(ğ‘Œ,ğ‘ŒË†)
Loss=Error(Y,Y^)
Following formula calculates the error With L2 Regularization function

ğ¿ğ‘œğ‘ ğ‘ =ğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(ğ‘Œâˆ’ğ‘ŒË†)+ğœ†âˆ‘1ğ‘›ğ‘¤2ğ‘–
Loss=Error(Yâˆ’Y^)+Î»âˆ‘1nwi2
Note

Here, if lambda is zero then you can imagine we get back OLS. However, if lambda is very large then it will add too much weight and it leads to under-fitting.

To understand the Note above,

Letâ€™s substitute the formula in finding new weights using Gradient Descent optimizer.

ğ‘¤ğ‘›ğ‘’ğ‘¤=ğ‘¤âˆ’ğœ‚âˆ‚ğ¿2âˆ‚ğ‘¤
wnew=wâˆ’Î·âˆ‚L2âˆ‚w
When we apply the L2 in above formula it becomes,

ğ‘¤ğ‘›ğ‘’ğ‘¤=ğ‘¤âˆ’ğœ‚.(ğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(ğ‘Œ,ğ‘ŒË†)+ğœ†âˆ‚ğ¿2âˆ‚ğ‘¤)=ğ‘¤âˆ’ğœ‚.(ğ¸ğ‘Ÿğ‘Ÿğ‘œğ‘Ÿ(ğ‘Œ,ğ‘ŒË†)+2ğœ†ğ‘¤)
wnew=wâˆ’Î·.(Error(Y,Y^)+Î»âˆ‚L2âˆ‚w)=wâˆ’Î·.(Error(Y,Y^)+2Î»w)
Simple python implementation

def update_weights_with_l2_regularization(features, targets, weights, lr,lambda):
     '''
     Features:(200, 3)
     Targets: (200, 1)
     Weights:(3, 1)
     '''
     predictions = predict(features, weights)

     #Extract our features
     x1 = features[:,0]
     x2 = features[:,1]
     x3 = features[:,2]

     # Use matrix cross product (*) to simultaneously
     # calculate the derivative for each weight
     d_w1 = -x1*(targets - predictions)
     d_w2 = -x2*(targets - predictions)
     d_w3 = -x3*(targets - predictions)

     # Multiply the mean derivative by the learning rate
     # and subtract from our weights (remember gradient points in direction of steepest ASCENT)

     weights[0][0] = weights[0][0] - lr * np.mean(d_w1) - 2 * lambda * weights[0][0]
     weights[1][0] = weights[1][0] - lr * np.mean(d_w2) - 2 * lambda * weights[1][0]
     weights[2][0] = weights[2][0] - lr * np.mean(d_w3) - 2 * lambda * weights[2][0]

     return weights
Use Case

L2 regularization can address the multicollinearity problem by constraining the coefficient norm and keeping all the variables. L2 regression can be used to estimate the predictor importance and penalize predictors that are not important. One issue with co-linearity is that the variance of the parameter estimate is huge. In cases where the number of features are greater than the number of observations, the matrix used in the OLS may not be invertible but Ridge Regression enables this matrix to be inverted.

Further reading

Ridge Regression

Architectures
Autoencoder
CNN
GAN
MLP
RNN
VAE
Autoencoder
TODO: Description of Autoencoder use case and basic architecture. Figure from [1].

_images/autoencoder.png
Model

An example implementation in PyTorch.

class Autoencoder(nn.Module):
    def __init__(self, in_shape):
        super().__init__()
        c,h,w = in_shape
        self.encoder = nn.Sequential(
            nn.Linear(c*h*w, 128),
            nn.ReLU(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, 12),
            nn.ReLU()
        )
        self.decoder = nn.Sequential(
            nn.Linear(12, 64),
            nn.ReLU(),
            nn.Linear(64, 128),
            nn.ReLU(),
            nn.Linear(128, c*h*w),
            nn.Sigmoid()
        )

    def forward(self, x):
        bs,c,h,w = x.size()
        x = x.view(bs, -1)
        x = self.encoder(x)
        x = self.decoder(x)
        x = x.view(bs, c, h, w)
        return x
Training

def train(net, loader, loss_func, optimizer):
    net.train()
    for inputs, _ in loader:
        inputs = Variable(inputs)

        output = net(inputs)
        loss = loss_func(output, inputs)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
Further reading

Convolutional Autoencoders
Deep Learning Book
CNN
TODO: Description of CNN use case and basic architecture. Figure from [2].

_images/cnn.jpeg
Model

An example implementation in PyTorch.

Training

Further reading

CS231 Convolutional Networks
Deep Learning Book
GAN
TODO: Description of GAN use case and basic architecture. Figure from [3].

_images/gan.png
Model

TODO: An example implementation in PyTorch.

Training

TODO

Further reading

Generative Adversarial Networks
Deep Learning Book
MLP
A Multi Layer Perceptron (MLP) is a neural network with only fully connected layers. Figure from [5].

_images/mlp.jpg
Model

An example implementation on FMNIST dataset in PyTorch. Full Code

The input to the network is a vector of size 28*28 i.e.(image from FashionMNIST dataset of dimension 28*28 pixels flattened to sigle dimension vector).
2 fully connected hidden layers.
Output layer with 10 outputs.(10 classes)
class MLP(nn.Module):
    def __init__(self):
        super(MLP,self).__init__()
        # define layers
        self.fc1 = nn.Linear(in_features=28*28, out_features=500)
        self.fc2 = nn.Linear(in_features=500, out_features=200)
        self.fc3 = nn.Linear(in_features=200, out_features=100)
        self.out = nn.Linear(in_features=100, out_features=10)


    def forward(self, t):
        # fc1  make input 1 dimentional
        t = t.view(-1,28*28)
        t = self.fc1(t)
        t = F.relu(t)
        # fc2
        t = self.fc2(t)
        t = F.relu(t)
        # fc3
        t = self.fc3(t)
        t = F.relu(t)
        # output
        t = self.out(t)
        return t
Training

def train(net, loader, loss_func, optimizer):
    net.train()
    n_batches = len(loader)
    for inputs, targets in loader:
        inputs = Variable(inputs)
        targets = Variable(targets)

        output = net(inputs)
        loss = loss_func(output, targets)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
         # print statistics
    running_loss = loss.item()
    print('Training loss: %.3f' %( running_loss))
Evaluating

def main():
    train_set = torchvision.datasets.FashionMNIST(
        root = './FMNIST',
        train = True,
        download = False,
        transform = transforms.Compose([
            transforms.ToTensor()
        ])
    )
    mlp = MLP()
    loader = torch.utils.data.DataLoader(train_set, batch_size = 1000)
    optimizer = optim.Adam(mlp.parameters(), lr=0.01)
    loss_func=nn.CrossEntropyLoss()
    for i in range(0,15):
        train(mlp,loader,loss_func,optimizer)
    print("Finished Training")
    torch.save(mlp.state_dict(), "./mlpmodel.pt")
    test_set = torchvision.datasets.FashionMNIST(
        root = './FMNIST',
        train = False,
        download = False,
        transform = transforms.Compose([
            transforms.ToTensor()
        ])
    )
    testloader = torch.utils.data.DataLoader(test_set, batch_size=4)
    correct = 0
    total = 0
    with torch.no_grad():
        for data in testloader:
            images, labels = data
            outputs = mlp(images)
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
    print('Accuracy of the network on the 10000 test images: %d %%' % (
        100 * correct / total))
Further reading

TODO

RNN
Description of RNN use case and basic architecture.

_images/rnn.png
Model

class RNN(nn.Module):
    def __init__(self, n_classes):
        super().__init__()
        self.hid_fc = nn.Linear(185, 128)
        self.out_fc = nn.Linear(185, n_classes)
        self.softmax = nn.LogSoftmax()
    
    def forward(self, inputs, hidden):
        inputs = inputs.view(1,-1)
        combined = torch.cat([inputs, hidden], dim=1)
        hid_out = self.hid_fc(combined)
        out = self.out_fc(combined)
        out = self.softmax(out)
        return out, hid_out
Training

In this example, our input is a list of last names, where each name is a variable length array of one-hot encoded characters. Our target is is a list of indices representing the class (language) of the name.

For each input name..
Initialize the hidden vector
Loop through the characters and predict the class
Pass the final characterâ€™s prediction to the loss function
Backprop and update the weights
def train(model, inputs, targets):
    for i in range(len(inputs)):
        target = Variable(targets[i])
        name = inputs[i]
        hidden = Variable(torch.zeros(1,128))
        model.zero_grad()
        
        for char in name:
            input_ = Variable(torch.FloatTensor(char))
            pred, hidden = model(input_, hidden)
        
        loss = criterion(pred, target)
        loss.backward()
        
        for p in model.parameters():
            p.data.add_(-.001, p.grad.data)
Further reading

Jupyter notebook
Deep Learning Book
VAE
Autoencoders can encode an input image to a latent vector and decode it, but they canâ€™t generate novel images. Variational Autoencoders (VAE) solve this problem by adding a constraint: the latent vector representation should model a unit gaussian distribution. The Encoder returns the mean and variance of the learned gaussian. To generate a new image, we pass a new mean and variance to the Decoder. In other words, we â€œsample a latent vectorâ€ from the gaussian and pass it to the Decoder. It also improves network generalization and avoids memorization. Figure from [4].

_images/vae.png
Loss Function

The VAE loss function combines reconstruction loss (e.g. Cross Entropy, MSE) with KL divergence.

def vae_loss(output, input, mean, logvar, loss_func):
    recon_loss = loss_func(output, input)
    kl_loss = torch.mean(0.5 * torch.sum(
        torch.exp(logvar) + mean**2 - 1. - logvar, 1))
    return recon_loss + kl_loss
Model

An example implementation in PyTorch of a Convolutional Variational Autoencoder.

class VAE(nn.Module):
    def __init__(self, in_shape, n_latent):
        super().__init__()
        self.in_shape = in_shape
        self.n_latent = n_latent
        c,h,w = in_shape
        self.z_dim = h//2**2 # receptive field downsampled 2 times
        self.encoder = nn.Sequential(
            nn.BatchNorm2d(c),
            nn.Conv2d(c, 32, kernel_size=4, stride=2, padding=1),  # 32, 16, 16
            nn.BatchNorm2d(32),
            nn.LeakyReLU(),
            nn.Conv2d(32, 64, kernel_size=4, stride=2, padding=1),  # 32, 8, 8
            nn.BatchNorm2d(64),
            nn.LeakyReLU(),
        )
        self.z_mean = nn.Linear(64 * self.z_dim**2, n_latent)
        self.z_var = nn.Linear(64 * self.z_dim**2, n_latent)
        self.z_develop = nn.Linear(n_latent, 64 * self.z_dim**2)
        self.decoder = nn.Sequential(
            nn.ConvTranspose2d(64, 32, kernel_size=3, stride=2, padding=0),
            nn.BatchNorm2d(32),
            nn.ReLU(),
            nn.ConvTranspose2d(32, 1, kernel_size=3, stride=2, padding=1),
            CenterCrop(h,w),
            nn.Sigmoid()
        )

    def sample_z(self, mean, logvar):
        stddev = torch.exp(0.5 * logvar)
        noise = Variable(torch.randn(stddev.size()))
        return (noise * stddev) + mean

    def encode(self, x):
        x = self.encoder(x)
        x = x.view(x.size(0), -1)
        mean = self.z_mean(x)
        var = self.z_var(x)
        return mean, var

    def decode(self, z):
        out = self.z_develop(z)
        out = out.view(z.size(0), 64, self.z_dim, self.z_dim)
        out = self.decoder(out)
        return out

    def forward(self, x):
        mean, logvar = self.encode(x)
        z = self.sample_z(mean, logvar)
        out = self.decode(z)
        return out, mean, logvar
Training

def train(model, loader, loss_func, optimizer):
    model.train()
    for inputs, _ in loader:
        inputs = Variable(inputs)

        output, mean, logvar = model(inputs)
        loss = vae_loss(output, inputs, mean, logvar, loss_func)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
Further reading

Original Paper
VAE Explained
Deep Learning Book

Classification Algorithms
Classification problems is when our output Y is always in categories like positive vs negative in terms of sentiment analysis, dog vs cat in terms of image classification and disease vs no disease in terms of medical diagnosis.

Bayesian
Overlaps..

Boosting
Be the first to contribute!

Decision Trees
ID3 decision tree: code example

K-Nearest Neighbor
Introduction

K-Nearest Neighbor is a supervised learning algorithm both for classification and regression. The principle is to find the predefined number of training samples closest to the new point, and predict the label from these training samples[1].

For example, when a new point comes, the algorithm will follow these steps:

Calculate the Euclidean distance between the new point and all training data
Pick the top-K closest training data
For regression problem, take the average of the labels as the result; for classification problem, take the most common label of these labels as the result.
Code

Below is the Numpy implementation of K-Nearest Neighbor function. Refer to code example for details.

def KNN(training_data, target, k, func):
    """
    training_data: all training data point
    target: new point
    k: user-defined constant, number of closest training data
    func: functions used to get the the target label
    """
    # Step one: calculate the Euclidean distance between the new point and all training data
    neighbors= []
    for index, data in enumerate(training_data):
        # distance between the target data and the current example from the data.
        distance = euclidean_distance(data[:-1], target)
        neighbors.append((distance, index))

    # Step two: pick the top-K closest training data
    sorted_neighbors = sorted(neighbors)
    k_nearest = sorted_neighbors[:k]
    k_nearest_labels = [training_data[i][1] for distance, i in k_nearest]

    # Step three: For regression problem, take the average of the labels as the result;
    #             for classification problem, take the most common label of these labels as the result.
    return k_nearest, func(k_nearest_labels)
Logistic Regression
Be the first to contribute!

Random Forests
Random Forest Classifier using ID3 Tree: code example

